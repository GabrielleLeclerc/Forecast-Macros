Option Explicit

'========================= SETTINGS =========================
Public Const GATE_BY As String = "ENDING"          ' "ENDING" | "BEGINNING" | "EXISTING"
Public Const EPS_NEG As Double = 0                 ' Any value < EPS_NEG fails (0 = strictly negative fails)
Public Const IGNORE_MISSING_BOX_ROWS As Boolean = True
Public Const WRITE_DEBUG As Boolean = True

' How many boxes do you have total?
Public Const MAX_BOX As Long = 8                  ' Adjust as needed

'Assuming the average order is a 3-seater sofa. 8 modules total, 2 boxes of arms, 3 boxes of seats, 3 boxes of backrests
'Share of new sales/backlog assumed to be Box 1, Box 2, Box 4, and Box 5
Public Const BOX1_SHARE As Double = 0.375         ' Seat, ~37.5% (changeable)
Public Const BOX2_SHARE As Double = 0            ' Backrest, ~37.5% (changeable)
Public Const BOX3_SHARE As Double = 0            ' Arm, ~25% (changeable)

' PnP: average boxes per PnP order (changeable)
Public Const PNP_BOX_ASSUMPTION As Double = 8

' ---------- Per-sheet weekly column spans (letters) ----------
Public Const MTL_START_COL As String = "BY"   'Week of 2025-12-01
Public Const MTL_END_COL   As String = "DH"
Public Const TO_START_COL  As String = "BY"   'Week of 2025-12-01
Public Const TO_END_COL    As String = "DH"
Public Const VAN_START_COL As String = "BY"   'Week of 2025-12-01
Public Const VAN_END_COL   As String = "DG"
Public Const IRN_START_COL As String = "BY"   'Week of 2025-12-01
Public Const IRN_END_COL   As String = "DI"
Public Const MOR_START_COL As String = "BY"   'Week of 2025-12-01
Public Const MOR_END_COL   As String = "DI"
Private Const CARRY_SHEET As String = "Boxes_Shipped_CARRY" ' Persist previous run's pending here

'============================================================
'==================== CROSS-PLATFORM MAP ====================
' Small wrapper that uses Scripting.Dictionary if present;
' otherwise falls back to a Collection storing [key, value] pairs.
' Keeps everything in ONE module (no class files needed).

Public Function Map_Create() As Object
    On Error Resume Next
    Dim d As Object
    Set d = CreateObject("Scripting.Dictionary") ' Windows & some Mac installs
    On Error GoTo 0
    If d Is Nothing Then
        Dim c As Collection
        Set c = New Collection
        Set Map_Create = c
    Else
        Set Map_Create = d
    End If
End Function

Public Sub Map_Set(ByVal m As Object, ByVal key As String, ByVal value As Double)
    If TypeName(m) = "Dictionary" Or TypeName(m) = "Scripting.Dictionary" Then
        m(key) = value
    Else
        ' Collection fallback — store [key, value] and use key for uniqueness
        On Error Resume Next
        m.Remove CStr(key)             ' remove if already exists
        Err.Clear
        m.Add Array(CStr(key), CDbl(value)), CStr(key)
        On Error GoTo 0
    End If
End Sub

Public Function Map_Get(ByVal m As Object, ByVal key As String, Optional ByVal defaultValue As Double = 0#) As Double
    If TypeName(m) = "Dictionary" Or TypeName(m) = "Scripting.Dictionary" Then
        If m.Exists(CStr(key)) Then
            Map_Get = CDbl(m(CStr(key)))
        Else
            Map_Get = defaultValue
        End If
    Else
        On Error Resume Next
        Dim itm As Variant
        itm = m.Item(CStr(key))        ' keyed access
        If Err.Number <> 0 Then
            Err.Clear
            Map_Get = defaultValue
        Else
            If IsArray(itm) Then
                If UBound(itm) >= 1 Then
                    Map_Get = CDbl(itm(1))
                Else
                    Map_Get = defaultValue
                End If
            Else
                Map_Get = CDbl(itm)
            End If
        End If
        On Error GoTo 0
    End If
End Function

Public Function Map_Exists(ByVal m As Object, ByVal key As String) As Boolean
    If TypeName(m) = "Dictionary" Or TypeName(m) = "Scripting.Dictionary" Then
        Map_Exists = m.Exists(CStr(key))
    Else
        On Error Resume Next
        Dim tmp As Variant
        tmp = m.Item(CStr(key))
        Map_Exists = (Err.Number = 0)
        Err.Clear
        On Error GoTo 0
    End If
End Function

Public Function Map_Keys(ByVal m As Object) As Variant
    If TypeName(m) = "Dictionary" Or TypeName(m) = "Scripting.Dictionary" Then
        Map_Keys = m.Keys
    Else
        Dim n As Long, i As Long
        n = m.Count
        If n = 0 Then
            Map_Keys = Empty
            Exit Function
        End If
        Dim arr() As String, v As Variant
        ReDim arr(1 To n)
        For i = 1 To n
            v = m.Item(i)              ' positional access
            If IsArray(v) Then
                arr(i) = CStr(v(0))    ' stored key
            Else
                arr(i) = ""            ' should not happen; keep safe
            End If
        Next i
        Map_Keys = arr
    End If
End Function

Public Function Map_Count(ByVal m As Object) As Long
    Map_Count = m.Count
End Function

'============================================================


'========================= ENTRY ============================
Public Sub BuildWeeklyBoxesShipped_ColsOnly()
    Const DBG_SHEET As String = "Boxes_Shipped_DEBUG"

    Dim dcSheets As Variant, dcNames As Variant
    dcSheets = VBA.Array("Luna-Montreal", "Luna-Toronto", "Luna-Vancouver", "Luna-Ironlink", "Luna-Moreno")
    dcNames  = VBA.Array("Montreal", "Toronto", "Vancouver", "Ironlink", "Moreno")

    Dim wb As Workbook: Set wb = ThisWorkbook

    ' Run-time rolling map: backlog within THIS macro run only
    Dim carryRun As Object
    Set carryRun = Map_Create()
    
    ' Map: P1 city | color | week -> P1_EndStockB1AfterNewSales
    Dim p1AfterNewMap As Object
    Set p1AfterNewMap = Map_Create()
    
    ' Maps for "after-local" availability per city/color/week (B1–B3)
    Dim afterLocalB1 As Object
    Dim afterLocalB2 As Object
    Dim afterLocalB3 As Object
    Set afterLocalB1 = Map_Create()
    Set afterLocalB2 = Map_Create()
    Set afterLocalB3 = Map_Create()


    ' ===== Speed up =====
    Dim prevCalc As XlCalculation, prevScr As Boolean, prevEvt As Boolean
    prevCalc = Application.Calculation
    prevScr = Application.ScreenUpdating
    prevEvt = Application.EnableEvents
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.Calculation = xlCalculationManual

    On Error GoTo cleanup

    ' ===== Prepare output sheet =====
    Dim wsDbg As Worksheet: Set wsDbg = EnsureOutputSheet(wb, DBG_SHEET)
    wsDbg.Cells.Clear

    ' Header: Demand view + inbound breakdown + ONE outbound total on SAME ROW
    Dim hdr() As Variant, k As Long, iCol As Long
    ReDim hdr(1 To 200)

    hdr(1) = "Demand City"
    hdr(2) = "Color"
    hdr(3) = "Week Start"
    hdr(4) = "Week End"
    hdr(5) = "Col"
    hdr(6) = "GateBy"
    
    hdr(7) = "LocalCorePass"
    hdr(8) = "Reason"          ' Local reason
    
    k = 8
    For iCol = 1 To MAX_BOX
        k = k + 1: hdr(k) = "Raw B" & iCol
    Next iCol
    
    For iCol = 1 To MAX_BOX
        k = k + 1: hdr(k) = "EligLocal B" & iCol
    Next iCol

    ' NEW: Ending Stock per box (local DC) - only B1..B3 in debug
    For iCol = 1 To 3
        k = k + 1: hdr(k) = "EndStock B" & iCol
    Next iCol


    ' We’ll show P1/P2 Box 1 stocks later next to their city blocks

    ' NEW: Available Stock per box (local DC) = EndStock + Raw
    ' Only keep B1, B2, B3 in the debug sheet
    For iCol = 1 To 3
        k = k + 1: hdr(k) = "AvailStock B" & iCol
    Next iCol


    ' --- Flow + P1 numeric logic, in requested order ---
    k = k + 1: hdr(k) = "NewSalesTotal"
    k = k + 1: hdr(k) = "Backlog"
    k = k + 1: hdr(k) = "TotalToShip"

    ' Detailed local B1/B2/B3 metrics
    k = k + 1: hdr(k) = "Local_BacklogB1_Needed"
    k = k + 1: hdr(k) = "Local_BacklogB2_Needed"
    k = k + 1: hdr(k) = "Local_BacklogB3_Needed"
    k = k + 1: hdr(k) = "FromLocal_Backlog"
    k = k + 1: hdr(k) = "Local_AvailB1_AfterBacklog"
    k = k + 1: hdr(k) = "Local_AvailB2_AfterBacklog"
    k = k + 1: hdr(k) = "Local_AvailB3_AfterBacklog"
    k = k + 1: hdr(k) = "FromLocal_NewSales"
    k = k + 1: hdr(k) = "Local_SalesB1_Needed"
    k = k + 1: hdr(k) = "Local_SalesB2_Needed"
    k = k + 1: hdr(k) = "Local_SalesB3_Needed"
    k = k + 1: hdr(k) = "FromLocal_Total"
    k = k + 1: hdr(k) = "Local_AvailB1_AfterNewSales"
    k = k + 1: hdr(k) = "Local_AvailB2_AfterNewSales"
    k = k + 1: hdr(k) = "Local_AvailB3_AfterNewSales"

    ' --- P1 block (B1/B2/B3), same structure as Local) ---
    k = k + 1: hdr(k) = "P1 City"
    k = k + 1: hdr(k) = "P1_AvailStockB1_afterLocal"
    k = k + 1: hdr(k) = "P1_AvailStockB2_afterLocal"
    k = k + 1: hdr(k) = "P1_AvailStockB3_afterLocal"
    k = k + 1: hdr(k) = "P1_BacklogB1_Needed"
    k = k + 1: hdr(k) = "P1_BacklogB2_Needed"
    k = k + 1: hdr(k) = "P1_BacklogB3_Needed"
    k = k + 1: hdr(k) = "FromP1_Backlog"
    k = k + 1: hdr(k) = "P1_AvailB1_AfterBacklog"
    k = k + 1: hdr(k) = "P1_AvailB2_AfterBacklog"
    k = k + 1: hdr(k) = "P1_AvailB3_AfterBacklog"
    k = k + 1: hdr(k) = "P1_SalesB1_Needed"
    k = k + 1: hdr(k) = "P1_SalesB2_Needed"
    k = k + 1: hdr(k) = "P1_SalesB3_Needed"
    k = k + 1: hdr(k) = "FromP1_NewSales"
    k = k + 1: hdr(k) = "FromP1_Total"
    k = k + 1: hdr(k) = "P1_AvailB1_AfterNewSales"
    k = k + 1: hdr(k) = "P1_AvailB2_AfterNewSales"
    k = k + 1: hdr(k) = "P1_AvailB3_AfterNewSales"

    ' --- P2 block (B1/B2/B3), same structure as Local) ---
    k = k + 1: hdr(k) = "P2 City"
    k = k + 1: hdr(k) = "P2_AvailB1_AfterP1"
    k = k + 1: hdr(k) = "P2_AvailB2_AfterP1"
    k = k + 1: hdr(k) = "P2_AvailB3_AfterP1"
    k = k + 1: hdr(k) = "P2_BacklogB1_Needed"
    k = k + 1: hdr(k) = "P2_BacklogB2_Needed"
    k = k + 1: hdr(k) = "P2_BacklogB3_Needed"
    k = k + 1: hdr(k) = "FromP2_Backlog"
    k = k + 1: hdr(k) = "P2_AvailB1_AfterBacklog"
    k = k + 1: hdr(k) = "P2_AvailB2_AfterBacklog"
    k = k + 1: hdr(k) = "P2_AvailB3_AfterBacklog"
    k = k + 1: hdr(k) = "P2_SalesB1_Needed"
    k = k + 1: hdr(k) = "P2_SalesB2_Needed"
    k = k + 1: hdr(k) = "P2_SalesB3_Needed"
    k = k + 1: hdr(k) = "FromP2_NewSales"
    k = k + 1: hdr(k) = "FromP2_Total"
    k = k + 1: hdr(k) = "P2_AvailB1_AfterNewSales"
    k = k + 1: hdr(k) = "P2_AvailB2_AfterNewSales"
    k = k + 1: hdr(k) = "P2_AvailB3_AfterNewSales"

    
    k = k + 1: hdr(k) = "BoxesShipped"
    k = k + 1: hdr(k) = "Unfulfilled"
    k = k + 1: hdr(k) = "OutOfCityTotal"

    
    Dim COL_COUNT As Long
    COL_COUNT = k
    wsDbg.Cells(1, 1).Resize(1, UBound(hdr)).Value = hdr


    Dim dbgRow As Long: dbgRow = 2

    ' ===== In-memory ORIGIN summary aggregator (for OutOfCityTotal) =====
    Dim keys() As String, tot() As Double, cnt As Long, cap As Long
    cap = 256: cnt = 0
    ReDim keys(1 To cap)
    ReDim tot(1 To cap)

    ' ===== Cache demand rows (to fill OutOfCityTotal after aggregation is complete) =====
    Dim rowCache As Collection: Set rowCache = New Collection

    ' ===== Iterate DEMAND cities and decide who ships each box/qty =====
    Dim iCity As Long
    For iCity = LBound(dcSheets) To UBound(dcSheets)

        Dim demandSheet As String: demandSheet = CStr(dcSheets(iCity))
        Dim demandCity  As String: demandCity  = CStr(dcNames(iCity))
        If Not SheetExists(demandSheet) Then GoTo NextSheet

        Dim wsDC As Worksheet: Set wsDC = wb.Worksheets(demandSheet)

        ' Weekly span
        Dim cStart As Long, cEnd As Long
        GetFixedSpan demandSheet, cStart, cEnd
        If cStart <= 0 Or cEnd < cStart Then GoTo NextSheet

        ' Sections
        Dim salesTbl As Variant, gateTbl As Variant, begTbl As Variant
        salesTbl = BuildSectionTable_Block(wsDC, "Sales")
        begTbl   = BuildSectionTable_Block(wsDC, "Beginning Stock")

        Select Case UCase$(GATE_BY)
            Case "ENDING":    gateTbl = BuildSectionTable_Block(wsDC, "Ending Stock")
            Case "BEGINNING": gateTbl = begTbl
            Case "EXISTING":  gateTbl = BuildSectionTable_Block(wsDC, "Existing")
            Case Else:        gateTbl = BuildSectionTable_Block(wsDC, "Ending Stock")
        End Select

        Dim colors As Collection: Set colors = UnionColors(salesTbl, gateTbl, begTbl)
        If colors Is Nothing Or colors.Count = 0 Then GoTo NextSheet

        ' Partners for this demand city
        Dim partNames As Variant, hasPartners As Boolean, pLB As Long, pUB As Long
        partNames = PartnersFor(demandSheet)
        hasPartners = GetArrayBounds(partNames, pLB, pUB)

        Dim partners() As Worksheet, partnerGate() As Variant, p As Long
        If hasPartners Then
            ReDim partners(pLB To pUB)
            ReDim partnerGate(pLB To pUB)
            For p = pLB To pUB
                If SheetExists(CStr(partNames(p))) Then
                    Set partners(p) = wb.Worksheets(CStr(partNames(p)))
                    Select Case UCase$(GATE_BY)
                        Case "ENDING":    partnerGate(p) = BuildSectionTable_Block(partners(p), "Ending Stock")
                        Case "BEGINNING": partnerGate(p) = BuildSectionTable_Block(partners(p), "Beginning Stock")
                        Case "EXISTING":  partnerGate(p) = BuildSectionTable_Block(partners(p), "Existing")
                    End Select
                End If
            Next p
        End If

        ' Week columns
        Dim c As Long
        For c = cStart To cEnd

            If Not IsDate(wsDC.Cells(2, c).Value) Or Not IsDate(wsDC.Cells(4, c).Value) Then GoTo NextCol
            Dim wkStart As Date: wkStart = CDate(wsDC.Cells(2, c).Value)
            Dim wkEnd   As Date: wkEnd   = CDate(wsDC.Cells(4, c).Value)

            ' Colors
            Dim clr As Variant
            For Each clr In colors
                Dim colorRaw As String: colorRaw = CStr(clr)
                Dim colorKey As String: colorKey = NormalizeColor(colorRaw)

                ' ---- Reset per-row state ----
                Dim raw() As Double, eligLocal() As Double, allowedLocal() As Boolean
                Dim endStock() As Double, availStock() As Double, backlogPerBox() As Double
                Dim endStockP1() As Double, endStockP2() As Double

                Dim coreBacklogUnits As Double
                Dim coreBoxesFail As Long
                Dim gateOK As Boolean
                Dim cg As Variant

                Dim coreBacklogUnits_P1 As Double
                Dim coreBoxesFail_P1 As Long
                Dim gateOK_P1 As Boolean

                Dim coreBacklogUnits_P2 As Double
                Dim coreBoxesFail_P2 As Long
                Dim gateOK_P2 As Boolean

                ReDim raw(1 To MAX_BOX)
                ReDim eligLocal(1 To MAX_BOX)

                ' NEW: P1 numeric Box 1–based gating debug
                Dim p1BacklogB1Needed As Double
                Dim p1SalesB1Needed As Double
                Dim p1EndStockB1_afterBacklog As Double
                Dim p1EndStockB1_afterNewSales As Double
                Dim p1BacklogB1_OK As Boolean
                Dim p1SalesB1_OK As Boolean

                ' NEW: P2 numeric Box 1–based gating debug (same idea as P1)
                Dim p2BacklogB1Needed As Double
                Dim p2SalesB1Needed As Double
                Dim p2EndStockB1_afterBacklog As Double
                Dim p2EndStockB1_afterNewSales As Double
                Dim p2BacklogB1_OK As Boolean
                Dim p2SalesB1_OK As Boolean

                Dim p2EndStockB1_afterP1 As Double   ' For P2_EndStockB1AfterP1

                ' --- P1 B1/B2/B3 detailed metrics ---
                Dim P1_AvailB1_afterLocal As Double
                Dim P1_AvailB2_afterLocal As Double
                Dim P1_AvailB3_afterLocal As Double

                Dim P1_BacklogB1_Needed As Double
                Dim P1_BacklogB2_Needed As Double
                Dim P1_BacklogB3_Needed As Double

                Dim P1_AvailB1_AfterBacklog As Double
                Dim P1_AvailB2_AfterBacklog As Double
                Dim P1_AvailB3_AfterBacklog As Double

                Dim P1_SalesB1_Needed As Double
                Dim P1_SalesB2_Needed As Double
                Dim P1_SalesB3_Needed As Double

                Dim P1_AvailB1_AfterNewSales As Double
                Dim P1_AvailB2_AfterNewSales As Double
                Dim P1_AvailB3_AfterNewSales As Double

                ' Reset them explicitly so they don’t carry over between rows
                P1_BacklogB1_Needed = 0#: P1_BacklogB2_Needed = 0#: P1_BacklogB3_Needed = 0#
                P1_SalesB1_Needed   = 0#: P1_SalesB2_Needed   = 0#: P1_SalesB3_Needed   = 0#

                ' --- P2 B1/B2/B3 detailed metrics ---
                Dim P2_AvailB1_AfterP1 As Double
                Dim P2_AvailB2_AfterP1 As Double
                Dim P2_AvailB3_AfterP1 As Double

                Dim P2_BacklogB1_Needed As Double
                Dim P2_BacklogB2_Needed As Double
                Dim P2_BacklogB3_Needed As Double

                Dim P2_AvailB1_AfterBacklog As Double
                Dim P2_AvailB2_AfterBacklog As Double
                Dim P2_AvailB3_AfterBacklog As Double

                Dim P2_SalesB1_Needed As Double
                Dim P2_SalesB2_Needed As Double
                Dim P2_SalesB3_Needed As Double

                Dim P2_AvailB1_AfterNewSales As Double
                Dim P2_AvailB2_AfterNewSales As Double
                Dim P2_AvailB3_AfterNewSales As Double

                ' Reset
                P2_BacklogB1_Needed = 0#: P2_BacklogB2_Needed = 0#: P2_BacklogB3_Needed = 0#
                P2_SalesB1_Needed   = 0#: P2_SalesB2_Needed   = 0#: P2_SalesB3_Needed   = 0#
                


                ' --- NEW LOCAL B1/B2/B3 DEBUG + CAPACITY VARS ---
                Dim Local_BacklogB1_Needed As Double
                Dim Local_BacklogB2_Needed As Double
                Dim Local_BacklogB3_Needed As Double

                Dim Local_SalesB1_Needed As Double
                Dim Local_SalesB2_Needed As Double
                Dim Local_SalesB3_Needed As Double

                Dim Local_AvailB1 As Double
                Dim Local_AvailB2 As Double
                Dim Local_AvailB3 As Double

                Dim Local_AvailB1_AfterBacklog As Double
                Dim Local_AvailB2_AfterBacklog As Double
                Dim Local_AvailB3_AfterBacklog As Double

                Dim Local_AvailB1_AfterNewSales As Double
                Dim Local_AvailB2_AfterNewSales As Double
                Dim Local_AvailB3_AfterNewSales As Double


                ReDim allowedLocal(1 To MAX_BOX)
                ReDim endStock(1 To MAX_BOX)
                ReDim availStock(1 To MAX_BOX)
                ReDim backlogPerBox(1 To MAX_BOX)
                ReDim endStockP1(1 To MAX_BOX)
                ReDim endStockP2(1 To MAX_BOX)

                ' Default P1 numeric gate values
                p1BacklogB1Needed = 0#
                p1SalesB1Needed = 0#
                p1BacklogB1_OK = False
                p1SalesB1_OK = False
                ' Start from raw P1 B1 stock; may be reduced if P1 handles backlog
                p1EndStockB1_afterBacklog = 0#

                ' Default P2 numeric gate values
                p2BacklogB1Needed = 0#
                p2SalesB1Needed = 0#
                p2BacklogB1_OK = False
                p2SalesB1_OK = False
                p2EndStockB1_afterBacklog = 0#
                p2EndStockB1_afterNewSales = 0#


                Dim b As Long, rr As Long, v As Double
                Dim fromLocal_Total As Double, fromP1_Total As Double, fromP2_Total As Double
                fromLocal_Total = 0#: fromP1_Total = 0#: fromP2_Total = 0#

                Dim fromLocal_Backlog As Double, fromP1_Backlog As Double, fromP2_Backlog As Double
                Dim fromLocal_NewSales As Double, fromP1_NewSales As Double, fromP2_NewSales As Double
                fromLocal_Backlog = 0#: fromP1_Backlog = 0#: fromP2_Backlog = 0#
                fromLocal_NewSales = 0#: fromP1_NewSales = 0#: fromP2_NewSales = 0#


                ' PATCH: planning flags/arrays for partners + origin week dates
                Dim canP1 As Boolean, canP2 As Boolean
                canP1 = False: canP2 = False
                
                Dim allowedP1() As Boolean, allowedP2() As Boolean
                Dim p1Pass As Boolean, p2Pass As Boolean
                Dim rz1 As String, rz2 As String
                
                Dim p1WkStart As Date, p1WkEnd As Date
                Dim p2WkStart As Date, p2WkEnd As Date
                p1WkStart = wkStart: p1WkEnd = wkEnd   ' defaults if we can’t read partner headings
                p2WkStart = wkStart: p2WkEnd = wkEnd

                Dim boxesShipped As Double

                ' ---- Raw demand (qty values) ----
                Dim salesTotalNew As Double
                salesTotalNew = 0#
                
                For b = 1 To MAX_BOX
                    rr = RowForInTable(salesTbl, colorKey, b)
                    If rr > 0 Then
                        v = ValD(wsDC.Cells(rr, c).Value)
                        If v > 0 Then raw(b) = v
                    End If
                    
                Next b
                
                ' SalesTotal_New = simple row-only sum of Raw B1..B12
                Dim rawSum As Double
                rawSum = 0#
                For b = 1 To MAX_BOX
                    rawSum = rawSum + raw(b)
                Next b
                salesTotalNew = rawSum
                If salesTotalNew <= 0 Then GoTo NextColor

                ' ---- Local gating ----
                Dim corePass As Boolean, reason As String
                AllowedBoxesForDC_Single wsDC, gateTbl, colorKey, c, CoreGroup(), corePass, reason, allowedLocal

                ' ---- Cover locally first ----
                'PATCH: mark local-eligible boxes, but do NOT ship yet
                Dim bb As Long
                For b = 1 To MAX_BOX
                    If raw(b) > 0 And allowedLocal(b) Then
                        eligLocal(b) = raw(b)
                    End If
                Next b


                ' ---- Cover remaining with partners in order; first eligible wins ----
                ' PATCH: precompute partner eligibility (no shipping yet)

                Dim p1Start As Long, p1End As Long, p1Col As Long, off1 As Long
                Dim p2Start As Long, p2End As Long, p2Col As Long, off2 As Long
                Dim p1Name As String, p2Name As String
                p1Name = "": p2Name = ""
                
                If hasPartners Then
                    ' Always set display names from partner list, regardless of gating outcome
                    p1Name = SheetCityName(CStr(partNames(pLB)))
                    If pUB >= pLB + 1 Then
                        p2Name = SheetCityName(CStr(partNames(pLB + 1)))
                    End If
                
                    ' Partner 1 (if present)
                    If Not partners(pLB) Is Nothing Then
                        GetFixedSpan partners(pLB).Name, p1Start, p1End
                        off1 = c - cStart: p1Col = p1Start + off1
                        If p1Col >= p1Start And p1Col <= p1End Then
                            ReDim allowedP1(1 To MAX_BOX)
                            AllowedBoxesForDC_Single partners(pLB), partnerGate(pLB), colorKey, p1Col, CoreGroup(), p1Pass, rz1, allowedP1
                            If p1Pass Then
                                canP1 = True
                                ' p1Name already set; no need to touch it
                                If IsDate(partners(pLB).Cells(2, p1Col).Value) Then p1WkStart = CDate(partners(pLB).Cells(2, p1Col).Value)
                                If IsDate(partners(pLB).Cells(4, p1Col).Value) Then p1WkEnd   = CDate(partners(pLB).Cells(4, p1Col).Value)
                            End If
                        End If
                    End If
                
                    ' Partner 2 (if present)
                    If pUB >= pLB + 1 Then
                        If Not partners(pLB + 1) Is Nothing Then
                            GetFixedSpan partners(pLB + 1).Name, p2Start, p2End
                            off2 = c - cStart: p2Col = p2Start + off2
                            If p2Col >= p2Start And p2Col <= p2End Then
                                ReDim allowedP2(1 To MAX_BOX)
                                AllowedBoxesForDC_Single partners(pLB + 1), partnerGate(pLB + 1), colorKey, p2Col, CoreGroup(), p2Pass, rz2, allowedP2
                                If p2Pass Then
                                    canP2 = True
                                    ' p2Name already set
                                    If IsDate(partners(pLB + 1).Cells(2, p2Col).Value) Then p2WkStart = CDate(partners(pLB + 1).Cells(2, p2Col).Value)
                                    If IsDate(partners(pLB + 1).Cells(4, p2Col).Value) Then p2WkEnd   = CDate(partners(pLB + 1).Cells(4, p2Col).Value)
                                End If
                            End If
                        End If
                    End If
                End If


                ' ==== Build ending-stock per box for partners (P1/P2) ====
                Dim bx As Long

                ' P1 ending stock per box (raw, regardless of whether P1 passes the gate)
               If hasPartners Then
                    If Not partners(pLB) Is Nothing Then
                        If p1Col >= p1Start And p1Col <= p1End Then
                            For bx = 1 To MAX_BOX
                                rr = RowForInTable(partnerGate(pLB), colorKey, bx)
                                If rr > 0 Then
                                    endStockP1(bx) = ValD(partners(pLB).Cells(rr, p1Col).Value)
                                Else
                                    endStockP1(bx) = 0#
                                End If
                            Next bx
                        Else
                            For bx = 1 To MAX_BOX
                                endStockP1(bx) = 0#
                            Next bx
                        End If
                    Else
                        For bx = 1 To MAX_BOX
                            endStockP1(bx) = 0#
                        Next bx
                    End If
                Else
                    For bx = 1 To MAX_BOX
                        endStockP1(bx) = 0#
                    Next bx
                End If


                ' Initialize post-backlog P1 B1 stock for numeric gating
                ' Use "after-local" pool for that city/week/color if we know it,
                ' otherwise fall back to raw partner end-stock.
                Dim keyP1Local As String
                p1EndStockB1_afterBacklog = endStockP1(1)   ' default

                If Len(p1Name) > 0 Then
                    keyP1Local = MakeKey(p1Name, colorKey, p1WkStart, p1WkEnd)
                    If Map_Exists(afterLocalB1, keyP1Local) Then
                        p1EndStockB1_afterBacklog = Map_Get(afterLocalB1, keyP1Local)
                    End If
                End If

                p1EndStockB1_afterNewSales = p1EndStockB1_afterBacklog   ' start equal

                ' P1 baseline availabilities for debug (after local)
                P1_AvailB1_afterLocal = p1EndStockB1_afterBacklog
                P1_AvailB2_afterLocal = 0#
                P1_AvailB3_afterLocal = 0#

                If Len(p1Name) > 0 Then
                    If Map_Exists(afterLocalB2, keyP1Local) Then
                        P1_AvailB2_afterLocal = Map_Get(afterLocalB2, keyP1Local)
                    End If
                    If Map_Exists(afterLocalB3, keyP1Local) Then
                        P1_AvailB3_afterLocal = Map_Get(afterLocalB3, keyP1Local)
                    End If
                End If

                ' Start "after backlog" as the same, will reduce if P1 takes backlog
                P1_AvailB1_AfterBacklog = P1_AvailB1_afterLocal
                P1_AvailB2_AfterBacklog = P1_AvailB2_afterLocal
                P1_AvailB3_AfterBacklog = P1_AvailB3_afterLocal

                ' Default "after new sales" = "after backlog" (if P1 ships nothing)
                P1_AvailB1_AfterNewSales = P1_AvailB1_AfterBacklog
                P1_AvailB2_AfterNewSales = P1_AvailB2_AfterBacklog
                P1_AvailB3_AfterNewSales = P1_AvailB3_AfterBacklog


                ' P2 ending stock per box (raw, regardless of whether P2 passes the gate)
                If hasPartners Then
                    If pUB >= pLB + 1 Then
                        If Not partners(pLB + 1) Is Nothing Then
                            ' Only read if the partner week column is valid
                            If p2Col >= p2Start And p2Col <= p2End Then
                                For bx = 1 To MAX_BOX
                                    rr = RowForInTable(partnerGate(pLB + 1), colorKey, bx)
                                    If rr > 0 Then
                                        endStockP2(bx) = ValD(partners(pLB + 1).Cells(rr, p2Col).Value)
                                    Else
                                        endStockP2(bx) = 0#
                                    End If
                                Next bx
                            Else
                                ' Column out of span: default to zeros
                                For bx = 1 To MAX_BOX
                                    endStockP2(bx) = 0#
                                Next bx
                            End If
                        Else
                            ' No P2 sheet object: default to zeros
                            For bx = 1 To MAX_BOX
                                endStockP2(bx) = 0#
                            Next bx
                        End If
                    Else
                        ' Only one partner total (no P2): default to zeros
                        For bx = 1 To MAX_BOX
                            endStockP2(bx) = 0#
                        Next bx
                    End If
                Else
                    ' No partners at all
                    For bx = 1 To MAX_BOX
                        endStockP2(bx) = 0#
                    Next bx
                End If



                ' ---- Stash row for later write (after we know OutOfCityTotal) ----
                Dim rowArr() As Variant, idx As Long
                ReDim rowArr(1 To COL_COUNT)
                
                rowArr(1) = demandCity
                rowArr(2) = colorRaw
                rowArr(3) = wkStart
                rowArr(4) = wkEnd
                rowArr(5) = ColN2L(c)
                rowArr(6) = UCase$(GATE_BY)
                
                rowArr(7)  = corePass   ' LocalCorePass
                rowArr(8)  = reason     ' Local Reason
                
                idx = 8


                ' Raw B1..B12
                For bb = 1 To MAX_BOX
                    idx = idx + 1: rowArr(idx) = raw(bb)
                Next bb
                
                ' EligLocal B1..B12
                For bb = 1 To MAX_BOX
                    idx = idx + 1: rowArr(idx) = eligLocal(bb)
                Next bb
                
                ' Ending Stock B1..B12 (local) – compute for all boxes
                Dim endVal As Double
                For bb = 1 To MAX_BOX
                    rr = RowForInTable(gateTbl, colorKey, bb)
                    If rr > 0 Then
                        endVal = ValD(wsDC.Cells(rr, c).Value)
                    Else
                        endVal = 0#
                    End If
                    endStock(bb) = endVal
                Next bb
                
                ' Only write EndStock B1..B3 to debug
                For bb = 1 To 3
                    idx = idx + 1
                    rowArr(idx) = endStock(bb)
                Next bb
                
                ' AvailableStockB = EndStockB + RawB   (local only, for all boxes)
                For bb = 1 To MAX_BOX
                    availStock(bb) = endStock(bb) + raw(bb)
                Next bb
                
                ' NEW: write AvailStock B1..B3 to debug
                For bb = 1 To 3
                    idx = idx + 1
                    rowArr(idx) = availStock(bb)
                Next bb

                ' Snapshot local available B1/B2/B3 before backlog
                Local_AvailB1 = availStock(1)
                Local_AvailB2 = availStock(2)
                Local_AvailB3 = availStock(3)

                ' Default "after backlog" and "after new sales" to pre-backlog values;
                ' we'll override if Local actually ships backlog and/or new sales.
                Local_AvailB1_AfterBacklog = Local_AvailB1
                Local_AvailB2_AfterBacklog = Local_AvailB2
                Local_AvailB3_AfterBacklog = Local_AvailB3

                Local_AvailB1_AfterNewSales = Local_AvailB1
                Local_AvailB2_AfterNewSales = Local_AvailB2
                Local_AvailB3_AfterNewSales = Local_AvailB3


                
                ' BacklogB:
                '   = 0              if EndStockB >= 0
                '   = Abs(EndStockB) if EndStockB < 0
                ' Still computed for logic, but no longer written to debug
                For bb = 1 To MAX_BOX
                    If endStock(bb) >= 0 Then
                        backlogPerBox(bb) = 0#
                    Else
                        backlogPerBox(bb) = Abs(endStock(bb))
                    End If
                Next bb

                
                ' === NEW: core-group numeric gating (LOCAL) ===
                coreBacklogUnits = 0#
                coreBoxesFail = 0
                
                For Each cg In CoreGroup()
                    b = CLng(cg)
                    If b >= 1 And b <= MAX_BOX Then
                        If backlogPerBox(b) > 0 Then
                            coreBacklogUnits = coreBacklogUnits + backlogPerBox(b)
                            coreBoxesFail = coreBoxesFail + 1
                        End If
                    End If
                Next cg
                
                gateOK = (coreBacklogUnits = 0#)  ' all core BacklogB are 0
                
                
                ' === NEW: core-group numeric gating (P1 / P2) ===
                coreBacklogUnits_P1 = 0#
                coreBoxesFail_P1 = 0
                gateOK_P1 = False
                
                coreBacklogUnits_P2 = 0#
                coreBoxesFail_P2 = 0
                gateOK_P2 = False
                
                ' P1: use partnerGate(pLB) at column p1Col, if partner is usable
                If canP1 Then
                    For Each cg In CoreGroup()
                        b = CLng(cg)
                        If b >= 1 And b <= MAX_BOX Then
                            rr = RowForInTable(partnerGate(pLB), colorKey, b)
                            If rr > 0 Then
                                endVal = ValD(partners(pLB).Cells(rr, p1Col).Value)
                            Else
                                endVal = 0#
                            End If
                            
                            If endVal < 0 Then
                                coreBacklogUnits_P1 = coreBacklogUnits_P1 + Abs(endVal)
                                coreBoxesFail_P1 = coreBoxesFail_P1 + 1
                            End If
                        End If
                    Next cg
                    gateOK_P1 = (coreBacklogUnits_P1 = 0#)
                End If
                
                ' P2: use partnerGate(pLB + 1) at column p2Col, if partner is usable
                If canP2 Then
                    For Each cg In CoreGroup()
                        b = CLng(cg)
                        If b >= 1 And b <= MAX_BOX Then
                            rr = RowForInTable(partnerGate(pLB + 1), colorKey, b)
                            If rr > 0 Then
                                endVal = ValD(partners(pLB + 1).Cells(rr, p2Col).Value)
                            Else
                                endVal = 0#
                            End If
                            
                            If endVal < 0 Then
                                coreBacklogUnits_P2 = coreBacklogUnits_P2 + Abs(endVal)
                                coreBoxesFail_P2 = coreBoxesFail_P2 + 1
                            End If
                        End If
                    Next cg
                    gateOK_P2 = (coreBacklogUnits_P2 = 0#)
                End If
                
                ' SalesTotal_New
                idx = idx + 1: rowArr(idx) = salesTotalNew



                ' Carryover: Backlog, TotalToShip   (week-agnostic carry key)
                Dim carryKey As String

                carryKey = MakeCarryKey(demandCity, colorKey)
                
                Dim backlog As Double
                If Map_Exists(carryRun, carryKey) Then
                    backlog = Map_Get(carryRun, carryKey)
                Else
                    backlog = 0#
                End If
                
                Dim totalToShip As Double
                totalToShip = salesTotalNew + backlog

                ' --- Local backlog box needs (B1/B2/B3) based on backlog ---
                Local_BacklogB1_Needed = BOX1_SHARE * backlog
                Local_BacklogB2_Needed = BOX2_SHARE * backlog
                Local_BacklogB3_Needed = BOX3_SHARE * backlog

                ' --- Compute P2_EndStockB1AfterP1 ---
                ' Start from raw end-stock; then adjust if we know after-local / after-P1.
                Dim keyP2After As String
                p2EndStockB1_afterP1 = endStockP2(1)

                If Len(p2Name) > 0 Then
                    keyP2After = MakeKey(p2Name, colorKey, p2WkStart, p2WkEnd)

                    ' 1) If this city already acted as P1 for this week+color,
                    '    use its P1_EndStockB1AfterNewSales (most depleted).
                    If Map_Exists(p1AfterNewMap, keyP2After) Then
                        p2EndStockB1_afterP1 = Map_Get(p1AfterNewMap, keyP2After)
                    ' 2) Else, if we at least know its after-local pool, use that.
                    ElseIf Map_Exists(afterLocalB1, keyP2After) Then
                        p2EndStockB1_afterP1 = Map_Get(afterLocalB1, keyP2After)
                    End If
                End If

                ' P2 Box1 stock after P1 effects is our baseline for backlog/new sales
                p2EndStockB1_afterBacklog = p2EndStockB1_afterP1
                p2EndStockB1_afterNewSales = p2EndStockB1_afterBacklog

                ' --- P2 baseline availabilities after P1 (for B1/B2/B3) ---
                P2_AvailB1_AfterP1 = p2EndStockB1_afterP1
                P2_AvailB2_AfterP1 = 0#
                P2_AvailB3_AfterP1 = 0#

                If Len(p2Name) > 0 Then
                    If Map_Exists(afterLocalB2, keyP2After) Then
                        P2_AvailB2_AfterP1 = Map_Get(afterLocalB2, keyP2After)
                    End If
                    If Map_Exists(afterLocalB3, keyP2After) Then
                        P2_AvailB3_AfterP1 = Map_Get(afterLocalB3, keyP2After)
                    End If    
                End If

                ' Defaults – will be reduced if P2 takes backlog and/or new sales
                P2_AvailB1_AfterBacklog = P2_AvailB1_AfterP1
                P2_AvailB2_AfterBacklog = P2_AvailB2_AfterP1
                P2_AvailB3_AfterBacklog = P2_AvailB3_AfterP1

                P2_AvailB1_AfterNewSales = P2_AvailB1_AfterBacklog
                P2_AvailB2_AfterNewSales = P2_AvailB2_AfterBacklog
                P2_AvailB3_AfterNewSales = P2_AvailB3_AfterBacklog

                ''' PATCH: ===== BLOCK A — Backlog (all-or-nothing) =====
                Dim planL_b As Double, planP1_b As Double, planP2_b As Double
                planL_b = 0#: planP1_b = 0#: planP2_b = 0#
                
                Dim needB As Double
                needB = backlog

                ' 1) Try Local first, using B1/B2/B3 capacity only (no corePass)
                If needB > 0 Then
                    If Local_BacklogB1_Needed <= Local_AvailB1 _
                       And Local_BacklogB2_Needed <= Local_AvailB2 _
                       And Local_BacklogB3_Needed <= Local_AvailB3 Then

                        ' Local can take ALL backlog
                        planL_b = needB
                        needB = 0#

                        ' Reduce local available B1/B2/B3 by implied backlog usage
                        Local_AvailB1_AfterBacklog = Local_AvailB1 - Local_BacklogB1_Needed
                        Local_AvailB2_AfterBacklog = Local_AvailB2 - Local_BacklogB2_Needed
                        Local_AvailB3_AfterBacklog = Local_AvailB3 - Local_BacklogB3_Needed
                    End If
                End If

                
                ' 2) If Local failed (or had no backlog), compute P1 need numerically
                '    We ALWAYS compute the theoretical Box1 need, even if P1 can't ship.
                If needB > 0 Then
                    ' P1 box needs for backlog
                    P1_BacklogB1_Needed = BOX1_SHARE * needB
                    P1_BacklogB2_Needed = BOX2_SHARE * needB
                    P1_BacklogB3_Needed = BOX3_SHARE * needB

                    If canP1 Then
                        ' Capacity gate: must have enough B1/B2/B3 after-local
                        If P1_BacklogB1_Needed <= P1_AvailB1_AfterBacklog _
                           And P1_BacklogB2_Needed <= P1_AvailB2_AfterBacklog _
                           And P1_BacklogB3_Needed <= P1_AvailB3_AfterBacklog Then

                            planP1_b = needB
                            needB = 0#

                            ' Consume capacity
                            P1_AvailB1_AfterBacklog = P1_AvailB1_AfterBacklog - P1_BacklogB1_Needed
                            P1_AvailB2_AfterBacklog = P1_AvailB2_AfterBacklog - P1_BacklogB2_Needed
                            P1_AvailB3_AfterBacklog = P1_AvailB3_AfterBacklog - P1_BacklogB3_Needed

                            p1BacklogB1Needed = P1_BacklogB1_Needed ' keep old B1 var if you still use it
                            p1EndStockB1_afterBacklog = P1_AvailB1_AfterBacklog
                            p1EndStockB1_afterNewSales = p1EndStockB1_afterBacklog
                        End If
                    End If
                End If

                
                ' 3) If backlog still remains, try P2 with full B1/B2/B3 gate
                If needB > 0 And canP2 And gateOK_P2 Then
                    ' P2 box needs for backlog
                    P2_BacklogB1_Needed = BOX1_SHARE * needB
                    P2_BacklogB2_Needed = BOX2_SHARE * needB
                    P2_BacklogB3_Needed = BOX3_SHARE * needB

                    If P2_BacklogB1_Needed <= P2_AvailB1_AfterBacklog _
                       And P2_BacklogB2_Needed <= P2_AvailB2_AfterBacklog _
                       And P2_BacklogB3_Needed <= P2_AvailB3_AfterBacklog Then

                        p2BacklogB1Needed = P2_BacklogB1_Needed   ' keep old scalar if you still inspect it
                        p2BacklogB1_OK = True

                        planP2_b = needB              ' P2 takes ALL remaining backlog
                        needB = 0#

                        ' Consume B1/B2/B3 capacity
                        P2_AvailB1_AfterBacklog = P2_AvailB1_AfterBacklog - P2_BacklogB1_Needed
                        P2_AvailB2_AfterBacklog = P2_AvailB2_AfterBacklog - P2_BacklogB2_Needed
                        P2_AvailB3_AfterBacklog = P2_AvailB3_AfterBacklog - P2_BacklogB3_Needed

                        ' Keep B1 scalar in sync
                        p2EndStockB1_afterBacklog = P2_AvailB1_AfterBacklog
                        p2EndStockB1_afterNewSales = p2EndStockB1_afterBacklog
                    Else
                        p2BacklogB1_OK = False
                    End If
                End If



                
                Dim backlogSucceeded As Boolean
                backlogSucceeded = (backlog = 0#) Or (needB <= 0#)
                
                Dim fromLocal_NewSales_tmp As Double, fromP1_NewSales_tmp As Double, fromP2_NewSales_tmp As Double
                If backlogSucceeded Then
                    ' Commit backlog shipments + OutOfCity attribution
                    If planL_b > 0 Then
                        fromLocal_Backlog = planL_b
                        UpdateOriginAgg keys, tot, cnt, cap, demandCity, demandCity, colorKey, wkStart, wkEnd, planL_b
                    End If
                    If planP1_b > 0 Then
                        fromP1_Backlog = planP1_b
                        UpdateOriginAgg keys, tot, cnt, cap, SheetCityName(partners(pLB).Name), demandCity, colorKey, p1WkStart, p1WkEnd, planP1_b
                    End If
                    If planP2_b > 0 Then
                        fromP2_Backlog = planP2_b
                        UpdateOriginAgg keys, tot, cnt, cap, SheetCityName(partners(pLB + 1).Name), demandCity, colorKey, p2WkStart, p2WkEnd, planP2_b
                    End If
                Else
                    ' Couldn’t cover all backlog -> no shipments at all this week; skip new sales too
                    fromLocal_Backlog = 0#: fromP1_Backlog = 0#: fromP2_Backlog = 0#
                    fromLocal_NewSales = 0#: fromP1_NewSales = 0#: fromP2_NewSales = 0#
                End If
                
                ''' PATCH: ===== BLOCK B — New sales (single-origin, all-or-nothing) =====
                fromLocal_NewSales = 0#: fromP1_NewSales = 0#: fromP2_NewSales = 0#
                
                If backlogSucceeded Then
                    Dim sumSales As Double
                    sumSales = salesTotalNew

                    ' Local new-sales box needs (B1/B2/B3)
                    Local_SalesB1_Needed = BOX1_SHARE * sumSales
                    Local_SalesB2_Needed = BOX2_SHARE * sumSales
                    Local_SalesB3_Needed = BOX3_SHARE * sumSales

                        ' Default: if no new sales from P1, then "after new sales" = "after backlog"
                        p1EndStockB1_afterNewSales = p1EndStockB1_afterBacklog
                    
                        ' === NEW: Local numeric-only gating for new sales ===
                        Dim allLocal As Boolean
                        allLocal = (Local_SalesB1_Needed <= Local_AvailB1_AfterBacklog _
                                    And Local_SalesB2_Needed <= Local_AvailB2_AfterBacklog _
                                    And Local_SalesB3_Needed <= Local_AvailB3_AfterBacklog)
                    
                        If allLocal Then
                            ' Local takes ALL new sales
                            fromLocal_NewSales = sumSales
                    
                            ' Consume B1/B2/B3 and compute post-new-sales availabilities
                            Local_AvailB1_AfterNewSales = Local_AvailB1_AfterBacklog - Local_SalesB1_Needed
                            Local_AvailB2_AfterNewSales = Local_AvailB2_AfterBacklog - Local_SalesB2_Needed
                            Local_AvailB3_AfterNewSales = Local_AvailB3_AfterBacklog - Local_SalesB3_Needed
                    
                            If sumSales > 0 Then
                                UpdateOriginAgg keys, tot, cnt, cap, demandCity, demandCity, colorKey, wkStart, wkEnd, sumSales
                            End If
                        Else
                            ' No local new sales; keep "after new sales" = "after backlog" for Local
                            Local_AvailB1_AfterNewSales = Local_AvailB1_AfterBacklog
                            Local_AvailB2_AfterNewSales = Local_AvailB2_AfterBacklog
                            Local_AvailB3_AfterNewSales = Local_AvailB3_AfterBacklog

                        ' NEW: P1 numeric gate for NEW SALES on B1/B2/B3
                        Dim p1CanShipNew As Boolean
                        p1CanShipNew = False

                        If canP1 Then
                            P1_SalesB1_Needed = BOX1_SHARE * sumSales
                            P1_SalesB2_Needed = BOX2_SHARE * sumSales
                            P1_SalesB3_Needed = BOX3_SHARE * sumSales

                            If P1_SalesB1_Needed <= P1_AvailB1_AfterBacklog _
                               And P1_SalesB2_Needed <= P1_AvailB2_AfterBacklog _
                               And P1_SalesB3_Needed <= P1_AvailB3_AfterBacklog Then

                                p1CanShipNew = True
                            End If
                        End If
                        
                        If p1CanShipNew Then
                            fromP1_NewSales = sumSales

                            ' Consume B1/B2/B3 and compute post-new-sales availabilities
                            P1_AvailB1_AfterNewSales = P1_AvailB1_AfterBacklog - P1_SalesB1_Needed
                            P1_AvailB2_AfterNewSales = P1_AvailB2_AfterBacklog - P1_SalesB2_Needed
                            P1_AvailB3_AfterNewSales = P1_AvailB3_AfterBacklog - P1_SalesB3_Needed

                            ' Keep the old scalar in sync
                            p1EndStockB1_afterNewSales = P1_AvailB1_AfterNewSales

                            If sumSales > 0 Then
                                UpdateOriginAgg keys, tot, cnt, cap, p1Name, demandCity, colorKey, p1WkStart, p1WkEnd, sumSales
                            End If
                        Else


                            ' NEW: P2 numeric gate for NEW SALES on B1/B2/B3
                            Dim p2CanShipNew As Boolean
                            p2CanShipNew = False
                            
                            If canP2 And gateOK_P2 Then
                                P2_SalesB1_Needed = BOX1_SHARE * sumSales
                                P2_SalesB2_Needed = BOX2_SHARE * sumSales
                                P2_SalesB3_Needed = BOX3_SHARE * sumSales

                                If P2_SalesB1_Needed <= P2_AvailB1_AfterBacklog _
                                   And P2_SalesB2_Needed <= P2_AvailB2_AfterBacklog _
                                   And P2_SalesB3_Needed <= P2_AvailB3_AfterBacklog Then

                                    p2CanShipNew = True
                                End If
                            End If
                            
                            If p2CanShipNew Then
                                fromP2_NewSales = sumSales
                                
                                ' Consume B1/B2/B3 and compute post-new-sales availabilities
                                P2_AvailB1_AfterNewSales = P2_AvailB1_AfterBacklog - P2_SalesB1_Needed
                                P2_AvailB2_AfterNewSales = P2_AvailB2_AfterBacklog - P2_SalesB2_Needed
                                P2_AvailB3_AfterNewSales = P2_AvailB3_AfterBacklog - P2_SalesB3_Needed

                                ' Keep the old scalar in sync
                                p2EndStockB1_afterNewSales = P2_AvailB1_AfterNewSales
                                
                                If sumSales > 0 Then
                                    UpdateOriginAgg keys, tot, cnt, cap, p2Name, demandCity, colorKey, p2WkStart, p2WkEnd, sumSales
                                End If
                            Else

                                ' No origin can ship the full set -> ship ZERO new sales
                                fromLocal_NewSales = 0#: fromP1_NewSales = 0#: fromP2_NewSales = 0#
                            End If
                        End If
                    End If
                End If

                ' === NEW: record after-local availability for this city/week/color ===
                Dim keyAfterLocal As String
                keyAfterLocal = MakeKey(demandCity, colorKey, wkStart, wkEnd)

                If backlogSucceeded Then
                    ' City can only donate if its backlog is fully handled (local + partners)
                    Map_Set afterLocalB1, keyAfterLocal, Local_AvailB1_AfterNewSales
                    Map_Set afterLocalB2, keyAfterLocal, Local_AvailB2_AfterNewSales
                    Map_Set afterLocalB3, keyAfterLocal, Local_AvailB3_AfterNewSales
                Else
                    ' Conservative: if backlog not fully covered, treat as no export capacity
                    Map_Set afterLocalB1, keyAfterLocal, 0#
                    Map_Set afterLocalB2, keyAfterLocal, 0#
                    Map_Set afterLocalB3, keyAfterLocal, 0#
                End If


                ' Totals per origin (used later when writing the row)
                fromLocal_Total = fromLocal_Backlog + fromLocal_NewSales
                fromP1_Total    = fromP1_Backlog    + fromP1_NewSales
                fromP2_Total    = fromP2_Backlog    + fromP2_NewSales

                ' Record P1 after-new-sales stock for this origin/week/color
                ' Only if P1 actually shipped something (backlog or new sales)
                If fromP1_Total > 0 And Len(p1Name) > 0 Then
                    Dim keyP1After As String
                    keyP1After = MakeKey(p1Name, colorKey, p1WkStart, p1WkEnd)
                    Map_Set p1AfterNewMap, keyP1After, p1EndStockB1_afterNewSales
                End If

                ' --- Flow, in the same order as the header ---

                ' Backlog / TotalToShip
                idx = idx + 1: rowArr(idx) = backlog
                idx = idx + 1: rowArr(idx) = totalToShip

                ' Local detailed B1/B2/B3 metrics
                idx = idx + 1: rowArr(idx) = Local_BacklogB1_Needed
                idx = idx + 1: rowArr(idx) = Local_BacklogB2_Needed
                idx = idx + 1: rowArr(idx) = Local_BacklogB3_Needed
                idx = idx + 1: rowArr(idx) = fromLocal_Backlog
                idx = idx + 1: rowArr(idx) = Local_AvailB1_AfterBacklog
                idx = idx + 1: rowArr(idx) = Local_AvailB2_AfterBacklog
                idx = idx + 1: rowArr(idx) = Local_AvailB3_AfterBacklog
                idx = idx + 1: rowArr(idx) = fromLocal_NewSales
                idx = idx + 1: rowArr(idx) = Local_SalesB1_Needed
                idx = idx + 1: rowArr(idx) = Local_SalesB2_Needed
                idx = idx + 1: rowArr(idx) = Local_SalesB3_Needed
                idx = idx + 1: rowArr(idx) = fromLocal_Total
                idx = idx + 1: rowArr(idx) = Local_AvailB1_AfterNewSales
                idx = idx + 1: rowArr(idx) = Local_AvailB2_AfterNewSales
                idx = idx + 1: rowArr(idx) = Local_AvailB3_AfterNewSales


                ' --- P1 block ---
                               
                idx = idx + 1: rowArr(idx) = p1Name
                idx = idx + 1: rowArr(idx) = P1_AvailB1_afterLocal
                idx = idx + 1: rowArr(idx) = P1_AvailB2_afterLocal
                idx = idx + 1: rowArr(idx) = P1_AvailB3_afterLocal
                idx = idx + 1: rowArr(idx) = P1_BacklogB1_Needed
                idx = idx + 1: rowArr(idx) = P1_BacklogB2_Needed
                idx = idx + 1: rowArr(idx) = P1_BacklogB3_Needed
                idx = idx + 1: rowArr(idx) = fromP1_Backlog
                idx = idx + 1: rowArr(idx) = P1_AvailB1_AfterBacklog
                idx = idx + 1: rowArr(idx) = P1_AvailB2_AfterBacklog
                idx = idx + 1: rowArr(idx) = P1_AvailB3_AfterBacklog
                idx = idx + 1: rowArr(idx) = P1_SalesB1_Needed
                idx = idx + 1: rowArr(idx) = P1_SalesB2_Needed
                idx = idx + 1: rowArr(idx) = P1_SalesB3_Needed
                idx = idx + 1: rowArr(idx) = fromP1_NewSales
                idx = idx + 1: rowArr(idx) = fromP1_Total
                idx = idx + 1: rowArr(idx) = P1_AvailB1_AfterNewSales
                idx = idx + 1: rowArr(idx) = P1_AvailB2_AfterNewSales
                idx = idx + 1: rowArr(idx) = P1_AvailB3_AfterNewSales

                ' --- P2 block ---
                idx = idx + 1: rowArr(idx) = p2Name
                idx = idx + 1: rowArr(idx) = P2_AvailB1_AfterP1
                idx = idx + 1: rowArr(idx) = P2_AvailB2_AfterP1
                idx = idx + 1: rowArr(idx) = P2_AvailB3_AfterP1
                idx = idx + 1: rowArr(idx) = P2_BacklogB1_Needed
                idx = idx + 1: rowArr(idx) = P2_BacklogB2_Needed
                idx = idx + 1: rowArr(idx) = P2_BacklogB3_Needed
                idx = idx + 1: rowArr(idx) = fromP2_Backlog
                idx = idx + 1: rowArr(idx) = P2_AvailB1_AfterBacklog
                idx = idx + 1: rowArr(idx) = P2_AvailB2_AfterBacklog
                idx = idx + 1: rowArr(idx) = P2_AvailB3_AfterBacklog
                idx = idx + 1: rowArr(idx) = P2_SalesB1_Needed
                idx = idx + 1: rowArr(idx) = P2_SalesB2_Needed
                idx = idx + 1: rowArr(idx) = P2_SalesB3_Needed
                idx = idx + 1: rowArr(idx) = fromP2_NewSales
                idx = idx + 1: rowArr(idx) = fromP2_Total
                idx = idx + 1: rowArr(idx) = P2_AvailB1_AfterNewSales
                idx = idx + 1: rowArr(idx) = P2_AvailB2_AfterNewSales
                idx = idx + 1: rowArr(idx) = P2_AvailB3_AfterNewSales

                
                ' BoxesShipped & Pending
                boxesShipped = fromLocal_Total + fromP1_Total + fromP2_Total
                Dim pendingThisWeek As Double
                pendingThisWeek = totalToShip - boxesShipped
                If pendingThisWeek < 0 Then pendingThisWeek = 0#
                
                Map_Set carryRun, carryKey, pendingThisWeek
                
                idx = idx + 1: rowArr(idx) = boxesShipped
                idx = idx + 1: rowArr(idx) = pendingThisWeek
                
                ' OutOfCityTotal placeholder (filled later)
                idx = idx + 1: rowArr(idx) = 0#
                
                ' Save normalized color key with the row
                rowCache.Add Array(rowArr, colorKey)


NextColor:
            Next clr

NextCol:
        Next c

NextSheet:
    Next iCity

    ' ===== Now write rows, filling OutOfCityTotal from aggregator =====
    Dim it As Variant, outKey As String, outIdx As Long
    For Each it In rowCache
        Dim rArr() As Variant: rArr = it(0)
        Dim outColorKey As String: outColorKey = it(1)
        outKey = MakeKey(CStr(rArr(1)), outColorKey, CDate(rArr(3)), CDate(rArr(4)))
        outIdx = FindKeyIndex(keys, cnt, outKey)
        If outIdx > 0 Then
            rArr(UBound(rArr)) = tot(outIdx)
        Else
            rArr(UBound(rArr)) = 0#
        End If
        wsDbg.Cells(dbgRow, 1).Resize(1, UBound(rArr)).Value = rArr
        dbgRow = dbgRow + 1
    Next it

    ' --- Persist the rolled carry map (City|Color -> latest pending) ---
    ' SaveCarryMap wb, carryRun
    ' ThisWorkbook.Worksheets(CARRY_SHEET).Visible = xlSheetHidden

   ' Format
    With wsDbg
        .Columns("A:ZZ").AutoFit
        If dbgRow > 2 Then .Range("C2:D" & dbgRow - 1).NumberFormat = "yyyy-mm-dd"
     End With

    ' NEW: build Boxes_Shipped_DEBUG_Frames containing only Color = "NONE"
    BuildBoxesShippedFrames wb, DBG_SHEET, "Boxes_Shipped_DEBUG_Frames"

    ' NEW: Step 3 – collapse DEBUG to only the key columns from the Frames sheet
    CollapseDebugToFrames wb, DBG_SHEET, "Boxes_Shipped_DEBUG_Frames"

    ' Hide the Frames sheet from view
    'ThisWorkbook.Worksheets("Boxes_Shipped_DEBUG_Frames").Visible = xlSheetHidden

    MsgBox "Done. Start week: Dec 1st 2025.", vbInformation

cleanup:
    Application.Calculation = prevCalc
    Application.EnableEvents = prevEvt
    Application.ScreenUpdating = prevScr
End Sub


'============================================================
'======================= CARRYOVER HELPERS ============================
Private Function EnsureCarrySheet(wb As Workbook) As Worksheet
    If SheetExists(CARRY_SHEET) Then
        Set EnsureCarrySheet = wb.Worksheets(CARRY_SHEET)
    Else
        Dim ws As Worksheet
        Set ws = wb.Worksheets.Add(After:=wb.Worksheets(wb.Worksheets.Count))
        ws.Name = CARRY_SHEET
        ws.Range("A1:B1").Value = Array("Key", "Pending_ThisWeek")
        Set EnsureCarrySheet = ws
    End If
End Function

Private Function LoadCarryMap(wb As Workbook) As Object
    Dim ws As Worksheet, lastRow As Long, d As Object
    Set ws = EnsureCarrySheet(wb)
    Set d = Map_Create()

    lastRow = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row
    If lastRow >= 2 Then
        Dim r As Long, k As String, v As Double, nk As String
        For r = 2 To lastRow
            k = CStr(ws.Cells(r, "A").Value)
            v = ValD(ws.Cells(r, "B").Value)
            If Len(k) > 0 Then
                nk = NormalizeCarryKey(k)          ' collapse City|Color|wkStart|wkEnd -> City|Color
                Map_Set d, nk, v
            End If
        Next r
    End If
    Set LoadCarryMap = d
End Function

Private Sub SaveCarryMap(wb As Workbook, ByVal carry As Object)
    Dim ws As Worksheet
    Set ws = EnsureCarrySheet(wb)
    ws.Rows("2:" & ws.Rows.Count).ClearContents

    If carry Is Nothing Then Exit Sub

    Dim n As Long
    n = Map_Count(carry)
    If n <= 0 Then Exit Sub

    Dim arr() As Variant, i As Long
    ReDim arr(1 To n, 1 To 2)

    Dim key As Variant, keys As Variant
    keys = Map_Keys(carry)
    i = 0
    If Not IsEmpty(keys) Then
        For Each key In keys
            i = i + 1
            arr(i, 1) = CStr(key)
            arr(i, 2) = Map_Get(carry, CStr(key))
        Next key
    End If

    If i > 0 Then ws.Range("A2").Resize(i, 2).Value = arr
End Sub

'======================= ORIGIN AGG (for OutOfCityTotal) ===========================
Private Sub UpdateOriginAgg(ByRef keys() As String, ByRef tot() As Double, _
                            ByRef cnt As Long, ByRef cap As Long, _
                            ByVal originCity As String, ByVal demandCity As String, _
                            ByVal colorKey As String, ByVal wkStart As Date, ByVal wkEnd As Date, _
                            ByVal qty As Double)
    Dim key As String
    key = MakeKey(originCity, colorKey, wkStart, wkEnd)
    Dim idx As Long: idx = FindKeyIndex(keys, cnt, key)
    If idx = 0 Then
        cnt = cnt + 1
        If cnt > cap Then
            cap = cap * 2
            ReDim Preserve keys(1 To cap)
            ReDim Preserve tot(1 To cap)
        End If
        idx = cnt
        keys(idx) = key
        tot(idx) = 0#
    End If
    tot(idx) = tot(idx) + qty
End Sub

Private Function MakeKey(ByVal city As String, ByVal colorKey As String, ByVal wkStart As Date, ByVal wkEnd As Date) As String
    MakeKey = UCase$(Trim$(city)) & "|" & UCase$(Trim$(colorKey)) & "|" & _
              Format$(wkStart, "yyyy-mm-dd") & "|" & Format$(wkEnd, "yyyy-mm-dd")
End Function

Private Function MakeCarryKey(ByVal city As String, ByVal colorKey As String) As String
    MakeCarryKey = UCase$(Trim$(city)) & "|" & UCase$(Trim$(colorKey))
End Function

' Back-compat: if an old carry sheet row still has a 4-part key (with dates),
' collapse it to the first 2 parts: City|Color
Private Function NormalizeCarryKey(ByVal k As String) As String
    Dim parts() As String
    parts = Split(k, "|")
    If UBound(parts) >= 1 Then
        NormalizeCarryKey = UCase$(Trim$(parts(0))) & "|" & UCase$(Trim$(parts(1)))
    Else
        NormalizeCarryKey = UCase$(Trim$(k))
    End If
End Function

Private Function FindKeyIndex(ByRef keys() As String, ByVal cnt As Long, ByVal key As String) As Long
    Dim i As Long
    For i = 1 To cnt
        If keys(i) = key Then FindKeyIndex = i: Exit Function
    Next i
End Function
'=============================================================================


'======================= COMMON HELPERS ============================
Private Function CoreGroup() As Variant
    CoreGroup = VBA.Array(1, 2, 3, 4, 5) ' core = 1..5
End Function

Private Function AddOnBoxes() As Variant
    Dim a() As Variant, b As Long, n As Long
    If MAX_BOX < 6 Then AddOnBoxes = VBA.Array(): Exit Function
    ReDim a(0 To MAX_BOX - 6)
    n = 0
    For b = 6 To MAX_BOX
        a(n) = b
        n = n + 1
    Next b
    AddOnBoxes = a
End Function

' ---------- Partner rules (priority order) ----------
Private Function PartnersFor(ByVal sheetName As String) As Variant
    Select Case sheetName
        Case "Luna-Montreal":  PartnersFor = VBA.Array("Luna-Toronto", "Luna-Vancouver")
        Case "Luna-Toronto":   PartnersFor = VBA.Array("Luna-Montreal", "Luna-Vancouver")
        Case "Luna-Vancouver": PartnersFor = VBA.Array("Luna-Toronto", "Luna-Montreal")  ' <-- order swapped
        Case "Luna-Ironlink":  PartnersFor = VBA.Array("Luna-Moreno")
        Case "Luna-Moreno":    PartnersFor = VBA.Array("Luna-Ironlink")
        Case Else:                PartnersFor = VBA.Array()
    End Select
End Function

' Display names for sheet names
Private Function SheetCityName(ByVal sheetName As String) As String
    Select Case sheetName
        Case "Luna-Montreal":  SheetCityName = "Montreal"
        Case "Luna-Toronto":   SheetCityName = "Toronto"
        Case "Luna-Vancouver": SheetCityName = "Vancouver"
        Case "Luna-Ironlink":  SheetCityName = "Ironlink"
        Case "Luna-Moreno":    SheetCityName = "Moreno"
        Case Else:                SheetCityName = sheetName
    End Select
End Function

' For outbound split label (not strictly required, but kept)
Private Sub OriginPartnerDisplay(ByVal originCity As String, ByRef p1Disp As String, ByRef p2Disp As String)
    Select Case originCity
        Case "Montreal":  p1Disp = "Toronto":  p2Disp = "Vancouver"
        Case "Toronto":   p1Disp = "Montreal": p2Disp = "Vancouver"
        Case "Vancouver": p1Disp = "Toronto":  p2Disp = "Montreal"  ' <-- order swapped
        Case "Ironlink":  p1Disp = "Moreno":   p2Disp = ""
        Case "Moreno":    p1Disp = "Ironlink": p2Disp = ""
        Case Else:        p1Disp = "":         p2Disp = ""
    End Select
End Sub

Private Sub GetFixedSpan(ByVal sheetName As String, ByRef startCol As Long, ByRef endCol As Long)
    Dim sStart As String, sEnd As String
    Select Case sheetName
        Case "Luna-Montreal":  sStart = MTL_START_COL: sEnd = MTL_END_COL
        Case "Luna-Toronto":   sStart = TO_START_COL:  sEnd = TO_END_COL
        Case "Luna-Vancouver": sStart = VAN_START_COL: sEnd = VAN_END_COL
        Case "Luna-Ironlink":  sStart = IRN_START_COL: sEnd = IRN_END_COL
        Case "Luna-Moreno":    sStart = MOR_START_COL: sEnd = MOR_END_COL
    End Select
    startCol = ColLetterToNumber(sStart)
    endCol   = ColLetterToNumber(sEnd)
End Sub

Private Function ColLetterToNumber(ByVal colLetters As String) As Long
    Dim s As String: s = UCase$(Trim$(colLetters))
    Dim i As Long, n As Long
    For i = 1 To Len(s)
        If Mid$(s, i, 1) < "A" Or Mid$(s, i, 1) > "Z" Then Exit For
        n = n * 26 + (Asc(Mid$(s, i, 1)) - Asc("A") + 1)
    Next i
    ColLetterToNumber = n
End Function

Private Function ColN2L(ByVal n As Long) As String
    Dim s As String, r As Long
    Do While n > 0
        r = (n - 1) Mod 26
        s = Chr$(Asc("A") + r) & s
        n = (n - 1) \ 26
    Loop
    ColN2L = s
End Function

Private Function EnsureOutputSheet(wb As Workbook, ByVal name As String) As Worksheet
    If SheetExists(name) Then
        Set EnsureOutputSheet = wb.Worksheets(name)
    Else
        Set EnsureOutputSheet = wb.Worksheets.Add(After:=wb.Worksheets(wb.Worksheets.Count))
        EnsureOutputSheet.Name = name
    End If
End Function

Private Sub BuildBoxesShippedFrames(wb As Workbook, _
                                    ByVal srcSheetName As String, _
                                    ByVal destSheetName As String)
    Dim wsSrc As Worksheet
    Dim wsDest As Worksheet
    Dim lastRow As Long
    Dim r As Long
    Dim outRow As Long
    Dim colorVal As String
    
    ' Source = Boxes_Shipped_DEBUG
    Set wsSrc = wb.Worksheets(srcSheetName)
    
    ' Destination = Boxes_Shipped_DEBUG_Frames (create if needed)
    Set wsDest = EnsureOutputSheet(wb, destSheetName)
    wsDest.Cells.Clear
    
    ' Copy header row
    wsSrc.Rows(1).Copy Destination:=wsDest.Rows(1)
    
    ' Find last row on the debug sheet (use column A)
    lastRow = wsSrc.Cells(wsSrc.Rows.Count, "A").End(xlUp).Row
    
    outRow = 2
    For r = 2 To lastRow
        colorVal = UCase$(Trim$(CStr(wsSrc.Cells(r, 2).Value))) ' column B = Color
        If colorVal = "NONE" Then
            wsSrc.Rows(r).Copy Destination:=wsDest.Rows(outRow)
            outRow = outRow + 1
        End If
    Next r
    
    ' Quick format
    wsDest.Columns("A:ZZ").AutoFit
End Sub

'============================================================
' Step 3 helper:
'   Take Boxes_Shipped_DEBUG_Frames, and overwrite Boxes_Shipped_DEBUG
'   with a smaller set of columns:
'   City, Color, Week Start, Week End, Col, Backlog, NewSalesTotal,
'   BoxesShipped, Unfulfilled, OutOfCityTotal
'============================================================
Private Sub CollapseDebugToFrames( _
    ByVal wb As Workbook, _
    ByVal debugSheetName As String, _
    ByVal framesSheetName As String)

    Dim wsSrc As Worksheet  ' Frames sheet
    Dim wsDest As Worksheet ' Debug sheet
    Dim lastRow As Long
    Dim r As Long, destRow As Long

    Set wsSrc = wb.Worksheets(framesSheetName)
    Set wsDest = wb.Worksheets(debugSheetName)

    ' --- Find source column indices by header text on row 1 ---
    Dim srcColDemandCity As Long
    Dim srcColColor As Long
    Dim srcColWeekStart As Long
    Dim srcColWeekEnd As Long
    Dim srcColColLabel As Long
    Dim srcColBacklog As Long
    Dim srcColNewSalesTotal As Long
    Dim srcColBoxesShipped As Long
    Dim srcColUnfulfilled As Long
    Dim srcColOutOfCity As Long

    srcColDemandCity   = FindHeaderColumn(wsSrc, "Demand City")
    srcColColor        = FindHeaderColumn(wsSrc, "Color")
    srcColWeekStart    = FindHeaderColumn(wsSrc, "Week Start")
    srcColWeekEnd      = FindHeaderColumn(wsSrc, "Week End")
    srcColColLabel     = FindHeaderColumn(wsSrc, "Col")
    srcColNewSalesTotal = FindHeaderColumn(wsSrc, "NewSalesTotal")
    srcColBacklog       = FindHeaderColumn(wsSrc, "Backlog")
    srcColBoxesShipped  = FindHeaderColumn(wsSrc, "BoxesShipped")
    srcColUnfulfilled   = FindHeaderColumn(wsSrc, "Unfulfilled")
    srcColOutOfCity     = FindHeaderColumn(wsSrc, "OutOfCityTotal")

    ' If any required header is missing, abort quietly
    If srcColDemandCity = 0 Or _
       srcColColor = 0 Or _
       srcColWeekStart = 0 Or _
       srcColWeekEnd = 0 Or _
       srcColColLabel = 0 Or _
       srcColNewSalesTotal = 0 Or _
       srcColBacklog = 0 Or _
       srcColBoxesShipped = 0 Or _
       srcColUnfulfilled = 0 Or _
       srcColOutOfCity = 0 Then
        Exit Sub
    End If

    ' --- Determine last data row on the Frames sheet (use Demand City column) ---
    lastRow = wsSrc.Cells(wsSrc.Rows.Count, srcColDemandCity).End(xlUp).Row

    ' --- Clear and rebuild the DEBUG sheet with a compact layout ---
    wsDest.Cells.Clear

    ' Header row in the FINAL debug sheet
    wsDest.Cells(1, 1).Value = "City"             ' from "Demand City"
    wsDest.Cells(1, 2).Value = "Color"
    wsDest.Cells(1, 3).Value = "Week Start"
    wsDest.Cells(1, 4).Value = "Week End"
    wsDest.Cells(1, 5).Value = "Col"
    wsDest.Cells(1, 6).Value = "Backlog"
    wsDest.Cells(1, 7).Value = "NewSalesTotal"
    wsDest.Cells(1, 8).Value = "BoxesShipped"
    wsDest.Cells(1, 9).Value = "Unfulfilled"
    wsDest.Cells(1, 10).Value = "OutOfCityTotal"
    wsDest.Cells(1, 11).Value = "PnP Boxes"                 
    wsDest.Cells(1, 12).Value = "Adjusted_OutOfCityTotal"   


    ' If there are no data rows, we’re done
    If lastRow < 2 Then
        wsDest.Columns("A:L").AutoFit
        Exit Sub
    End If

    ' --- Copy only the requested columns from Frames into Debug ---
    destRow = 2
    For r = 2 To lastRow
        ' Optionally skip completely blank rows
        If Application.WorksheetFunction.CountA(wsSrc.Rows(r)) > 0 Then

            Dim outOfCityVal As Double
            Dim pnpBoxes As Double
            Dim adjustedOut As Double

            ' Read OutOfCityTotal from the Frames sheet
            outOfCityVal = ValD(wsSrc.Cells(r, srcColOutOfCity).Value)

            ' Compute PnP Boxes and Adjusted_OutOfCityTotal (ROW-BY-ROW, NOT CUMULATIVE)
            pnpBoxes = outOfCityVal / PNP_BOX_ASSUMPTION
            adjustedOut = outOfCityVal + pnpBoxes

            ' Copy core fields
            wsDest.Cells(destRow, 1).Value = wsSrc.Cells(r, srcColDemandCity).Value
            wsDest.Cells(destRow, 2).Value = wsSrc.Cells(r, srcColColor).Value
            wsDest.Cells(destRow, 3).Value = wsSrc.Cells(r, srcColWeekStart).Value
            wsDest.Cells(destRow, 4).Value = wsSrc.Cells(r, srcColWeekEnd).Value
            wsDest.Cells(destRow, 5).Value = wsSrc.Cells(r, srcColColLabel).Value
            wsDest.Cells(destRow, 6).Value = wsSrc.Cells(r, srcColBacklog).Value
            wsDest.Cells(destRow, 7).Value = wsSrc.Cells(r, srcColNewSalesTotal).Value
            wsDest.Cells(destRow, 8).Value = wsSrc.Cells(r, srcColBoxesShipped).Value
            wsDest.Cells(destRow, 9).Value = wsSrc.Cells(r, srcColUnfulfilled).Value

            ' Original OutOfCityTotal
            wsDest.Cells(destRow, 10).Value = outOfCityVal

            ' NEW: PnP Boxes & Adjusted_OutOfCityTotal
            wsDest.Cells(destRow, 11).Value = pnpBoxes
            wsDest.Cells(destRow, 12).Value = adjustedOut

            destRow = destRow + 1
        End If
    Next r

    ' Basic formatting
    With wsDest
        .Columns("A:L").AutoFit
        If destRow > 2 Then
            .Range("C2:D" & destRow - 1).NumberFormat = "yyyy-mm-dd"
        End If
    End With
End Sub

' Find a header text in row 1 (case-insensitive) and return its column index.
' Returns 0 if not found.
Private Function FindHeaderColumn(ByVal ws As Worksheet, ByVal headerText As String) As Long
    Dim lastCol As Long
    Dim c As Long
    Dim target As String

    target = UCase$(Trim$(headerText))
    If Len(target) = 0 Then Exit Function

    lastCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column

    For c = 1 To lastCol
        If UCase$(Trim$(CStr(ws.Cells(1, c).Value))) = target Then
            FindHeaderColumn = c
            Exit Function
        End If
    Next c
End Function


Private Function SheetExists(ByVal name As String) As Boolean
    On Error Resume Next
    SheetExists = Not ThisWorkbook.Worksheets(name) Is Nothing
    On Error GoTo 0
End Function

Private Function NormalizeColor(ByVal s As String) As String
    Dim t As String
    t = CStr(s)
    t = Replace(t, Chr(160), " ")
    On Error Resume Next: t = Replace(t, ChrW(160), " "): On Error GoTo 0
    On Error Resume Next: t = WorksheetFunction.Trim(WorksheetFunction.Clean(t)): On Error GoTo 0
    NormalizeColor = UCase$(Trim$(t))
End Function

Private Function BuildSectionTable_Block(ws As Worksheet, ByVal sectionName As String) As Variant
    Dim lastRow As Long: lastRow = ws.Cells(ws.Rows.Count, "C").End(xlUp).Row
    Dim r As Long, rStart As Long, rEnd As Long

    For r = 1 To lastRow
        If UCase$(Trim$(CStr(ws.Cells(r, "C").Value))) = UCase$(sectionName) Then
            rStart = r + 1
            Exit For
        End If
    Next r
    If rStart = 0 Then BuildSectionTable_Block = Empty: Exit Function

    rEnd = lastRow
    For r = rStart To lastRow
        Dim hdr As String: hdr = UCase$(Trim$(CStr(ws.Cells(r, "C").Value)))
        If (hdr = "BEGINNING STOCK") Or (hdr = "ENDING STOCK") Or (hdr = "SALES") Or (hdr = "EXISTING") Or (hdr = "TO BE RECEIVED") Then
            If r > rStart Then rEnd = r - 1
            Exit For
        End If
    Next r

    Dim tmp() As Variant, cnt As Long: ReDim tmp(1 To 3, 1 To 1)
    Dim lastColorKey As String: lastColorKey = ""

    For r = rStart To rEnd
        Dim desc As String: desc = CStr(ws.Cells(r, "D").Value)
        Dim bx As Long: bx = ParseBoxNum(desc)
        If bx = 0 Then GoTo NextRow

        ' ignore "Box 8 - NEW ARMS/SRMS"
        If bx = 8 Then
            Dim U8 As String: U8 = UCase$(desc)
            If (InStr(1, U8, "NEW") > 0) And (InStr(1, U8, "ARMS") > 0 Or InStr(1, U8, "SRMS") > 0) Then GoTo NextRow
        End If

        Dim colorRaw As String, colorKey As String
        colorRaw = CStr(ws.Cells(r, "E").Value)
        colorKey = ""
        If IsLikelyColor(colorRaw) Then colorKey = NormalizeColor(colorRaw)
        If Len(colorKey) = 0 And Len(lastColorKey) > 0 Then colorKey = lastColorKey
        If Len(colorKey) = 0 Then GoTo NextRow
        lastColorKey = colorKey

        cnt = cnt + 1
        If cnt > UBound(tmp, 2) Then ReDim Preserve tmp(1 To 3, 1 To cnt)
        tmp(1, cnt) = colorKey
        tmp(2, cnt) = bx
        tmp(3, cnt) = r
NextRow:
    Next r

    If cnt = 0 Then BuildSectionTable_Block = Empty Else BuildSectionTable_Block = tmp
End Function

Private Function IsLikelyColor(ByVal v As Variant) As Boolean
    Dim s As String: s = Trim$(CStr(v))
    If Len(s) = 0 Then Exit Function
    If IsNumeric(s) Then Exit Function
    On Error Resume Next
    If IsDate(s) Then Exit Function
    On Error GoTo 0
    Dim i As Long, ch As String
    For i = 1 To Len(s)
        ch = Mid$(s, i, 1)
        If ch Like "[A-Za-z]" Then IsLikelyColor = True: Exit Function
    Next i
End Function

Private Function ParseBoxNum(ByVal s As String) As Long
    Dim U As String: U = UCase$(s)
    Dim p As Long: p = InStr(1, U, "BOX")
    If p = 0 Then Exit Function
    Dim i As Long, ch As String, numStr As String
    For i = p + 3 To Len(U)
        ch = Mid$(U, i, 1)
        If ch = " " Or ch = "-" Or ch = ChrW(8211) Or ch = ChrW(8212) Or ch = ChrW(160) Then
            ' skip
        ElseIf ch Like "#" Then
            numStr = numStr & ch
        ElseIf Len(numStr) > 0 Then
            Exit For
        End If
    Next i
    If Len(numStr) > 0 Then ParseBoxNum = CLng(numStr)
End Function

Private Function RowForInTable(tbl As Variant, ByVal colorKey As String, ByVal boxNum As Long) As Long
    If IsEmpty(tbl) Then Exit Function
    Dim i As Long
    For i = 1 To UBound(tbl, 2)
        If CStr(tbl(1, i)) = colorKey And CLng(tbl(2, i)) = boxNum Then
            RowForInTable = CLng(tbl(3, i))
            Exit Function
        End If
    Next i
End Function

Private Function UnionColors(ParamArray tbls() As Variant) As Collection
    Dim c As New Collection, t As Variant, i As Long, clr As String
    On Error GoTo done
    For Each t In tbls
        If Not IsEmpty(t) Then
            For i = 1 To UBound(t, 2)
                clr = CStr(t(1, i))
                If Len(clr) > 0 Then On Error Resume Next: c.Add clr, clr: On Error GoTo 0
            Next i
        End If
    Next t
done:
    Set UnionColors = c
End Function

' ==== Single-group gating + add-ons ====
Private Sub AllowedBoxesForDC_Single(ws As Worksheet, gateTbl As Variant, ByVal key As String, ByVal colIdx As Long, ByRef coreGrp As Variant, ByRef passCore As Boolean, ByRef reason As String, ByRef allowed() As Boolean)
    Dim b As Long
    ReDim allowed(1 To MAX_BOX)
    For b = 1 To MAX_BOX: allowed(b) = False: Next b

    passCore = SectionAvailable_Table(ws, gateTbl, key, colIdx, coreGrp, reason)

    If passCore Then
        Dim k As Long
        For k = LBound(coreGrp) To UBound(coreGrp)
            b = CLng(coreGrp(k))
            If b >= 1 And b <= MAX_BOX Then allowed(b) = True
        Next k
        Dim ao As Variant
        For Each ao In AddOnBoxes()
            b = CLng(ao)
            If b >= 1 And b <= MAX_BOX Then allowed(b) = True
        Next ao
    End If
End Sub

Private Function SectionAvailable_Table(ws As Worksheet, gateTbl As Variant, ByVal colorKey As String, ByVal colIdx As Long, ByRef grp As Variant, ByRef reason As String) As Boolean
    reason = ""
    If IsEmpty(gateTbl) Then reason = "Gate section not found": Exit Function

    Dim hasAny As Boolean, k As Long, b As Long, r As Long, v As Double
    For k = LBound(grp) To UBound(grp)
        b = CLng(grp(k))
        r = RowForInTable(gateTbl, colorKey, b)
        If r = 0 Then
            If IGNORE_MISSING_BOX_ROWS Then
                ' skip
            Else
                reason = "Missing box " & b & " row"
                Exit Function
            End If
        Else
            hasAny = True
            v = ValD(ws.Cells(r, colIdx).Value)
            If v < EPS_NEG Then
                reason = "Box " & b & " < 0 at " & ws.Name & "!" & ws.Cells(r, colIdx).Address(False, False)
                Exit Function
            End If
        End If
    Next k

    If Not hasAny Then reason = "No boxes from group found": Exit Function
    SectionAvailable_Table = True
End Function

' Robust numeric parser
Private Function ValD(ByVal v As Variant) As Double
    On Error GoTo fail

    If Not IsError(v) And Not IsNull(v) Then
        If IsNumeric(v) Then ValD = CDbl(v): Exit Function
    End If

    Dim s As String
    s = CStr(v)
    s = Replace(s, Chr$(160), " ")
    On Error Resume Next: s = Replace(s, ChrW$(160), " "): On Error GoTo 0
    s = Replace(s, ",", "")
    s = Trim$(s)
    If Len(s) = 0 Then Exit Function

    ' normalize various minus characters
    s = Replace(s, ChrW$(8722), "-")
    s = Replace(s, ChrW$(8211), "-")
    s = Replace(s, ChrW$(8212), "-")
    s = Replace(s, ChrW$(8210), "-")

    If Left$(s, 1) = "(" And Right$(s, 1) = ")" Then s = "-" & Mid$(s, 2, Len(s) - 2)

    s = Replace(s, "$", "")
    s = Replace(s, " ", "")
    If Right$(s, 1) = "%" Then s = Left$(s, Len(s) - 1)

    If IsNumeric(s) Then ValD = CDbl(s): Exit Function

fail:
    ValD = 0#
End Function

' Safe bounds for VBA.Array (handles empty)
Private Function GetArrayBounds(ByVal arr As Variant, ByRef lb As Long, ByRef ub As Long) As Boolean
    On Error Resume Next
    lb = LBound(arr): ub = UBound(arr)
    GetArrayBounds = (Err.Number = 0 And ub >= lb)
    Err.Clear
    On Error GoTo 0
End Function
'============================================================
