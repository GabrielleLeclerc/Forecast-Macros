Option Explicit

Public MAX_BOX As Long

'==================== CONFIG (things that vary) ====================
Private Const CFG_ASSUMPTIONS_SHEET As String = "Boxes_Shipped_Assumptions"

'Preferred table names (fast path). If names change, we’ll fall back to matching by required headers.
Private Const CFG_TABLE_WORKSHEETS_PREFERRED As String = "WorksheetNames"
Private Const CFG_TABLE_COLORS_PREFERRED As String = "Colors"
Private Const CFG_TABLE_BOXES_PREFERRED As String = "Boxes"

'Forecast start cell (in assumptions sheet) - change once here if needed
Private Const CFG_FORECAST_START_CELL As String = "B1"

'Alias headers (column names can differ across files)
Private CFG_WORKSHEET_HEADERS As Variant
Private CFG_COUNTRY_HEADERS As Variant
Private CFG_COLOR_HEADERS As Variant
Private CFG_STATUS_HEADERS As Variant

'Section labels (can differ across files)
Private CFG_SECTION_LABELS As Variant

'How many columns to scan when trying to detect where the section headers live
Private Const CFG_SECTION_SCAN_FIRST_N_COLS As Long = 20

Private Sub InitConfig()
    CFG_WORKSHEET_HEADERS = Array("Worksheet", "Sheet", "Tab", "SheetName")
    CFG_COUNTRY_HEADERS = Array("Country", "Market", "Region")

    CFG_COLOR_HEADERS = Array("Color", "Colour", "Colors", "Variant", "Finish")
    CFG_STATUS_HEADERS = Array("Status", "Active", "IsActive", "Enabled")

    CFG_SECTION_LABELS = Array("Beginning Stock", "Ending Stock", "Sales", "POs to be received", "Stock Turnover")
End Sub


'==================== TABLE + COLUMN RESOLUTION HELPERS ====================

Private Function FindTableByHeaders(ByVal requiredHeaders As Variant, Optional ByVal preferredName As String = vbNullString) As ListObject
    Dim ws As Worksheet, lo As ListObject

    'Fast path: try preferred name on any sheet
    If Len(preferredName) > 0 Then
        For Each ws In ThisWorkbook.Worksheets
            On Error Resume Next
            Set lo = ws.ListObjects(preferredName)
            On Error GoTo 0
            If Not lo Is Nothing Then
                If TableHasAllHeaders(lo, requiredHeaders) Then
                    Set FindTableByHeaders = lo
                    Exit Function
                End If
            End If
            Set lo = Nothing
        Next ws
    End If

    'Fallback: find any table with required headers
    For Each ws In ThisWorkbook.Worksheets
        For Each lo In ws.ListObjects
            If TableHasAllHeaders(lo, requiredHeaders) Then
                Set FindTableByHeaders = lo
                Exit Function
            End If
        Next lo
    Next ws
End Function

Private Function TableHasAllHeaders(ByVal lo As ListObject, ByVal requiredHeaders As Variant) As Boolean
    Dim h As Variant
    For Each h In requiredHeaders
        If GetListColumnIndexByAliases(lo, Array(CStr(h))) = 0 Then
            TableHasAllHeaders = False
            Exit Function
        End If
    Next h
    TableHasAllHeaders = True
End Function

Private Function GetListColumnIndexByAliases(ByVal lo As ListObject, ByVal aliases As Variant) As Long
    Dim a As Variant, lc As ListColumn
    For Each a In aliases
        For Each lc In lo.ListColumns
            If StrComp(Trim$(lc.Name), Trim$(CStr(a)), vbTextCompare) = 0 Then
                GetListColumnIndexByAliases = lc.Index
                Exit Function
            End If
        Next lc
    Next a
End Function


'==================== SECTION COLUMN / DESC+COLOR COLUMN DETECTION ====================

'Find the column number (on ws) that contains section headers like "Sales", "Beginning Stock", etc.
Private Function FindSectionHeaderColumn(ByVal ws As Worksheet) As Long
    Dim c As Long, hits As Long, lbl As Variant

    For c = 1 To CFG_SECTION_SCAN_FIRST_N_COLS
        hits = 0
        For Each lbl In CFG_SECTION_LABELS
            If Not FindInColumnExact_Num(ws, c, CStr(lbl)) Is Nothing Then hits = hits + 1
        Next lbl
        If hits >= 2 Then
            FindSectionHeaderColumn = c
            Exit Function
        End If
    Next c

    FindSectionHeaderColumn = 0
End Function

'Guess which columns inside a section block are Description vs Color (relative to sectionRng).
'descRelCol / colorRelCol are 1-based indices within sectionRng.
Private Sub GuessDescAndColorColumns(ByVal sectionRng As Range, ByRef descRelCol As Long, ByRef colorRelCol As Long)
    Dim relC As Long, r As Long, s As String
    Dim maxCols As Long
    maxCols = MinL(sectionRng.Columns.Count, 6) 'only inspect first few columns in the block

    Dim boxHits() As Long, textHits() As Long, blankHits() As Long
    ReDim boxHits(1 To maxCols)
    ReDim textHits(1 To maxCols)
    ReDim blankHits(1 To maxCols)

    For relC = 1 To maxCols
        For r = 1 To sectionRng.Rows.Count
            s = Trim$(CStr(sectionRng.Cells(r, relC).value))

            If Len(s) = 0 Then
                blankHits(relC) = blankHits(relC) + 1
            Else
                If InStr(1, UCase$(s), "BOX") > 0 Then boxHits(relC) = boxHits(relC) + 1
                If IsLikelyColor(s) Then textHits(relC) = textHits(relC) + 1
            End If
        Next r
    Next relC

    'Description column = most "BOX" hits
    Dim best As Long, bestScore As Long
    best = 1: bestScore = -1
    For relC = 1 To maxCols
        If boxHits(relC) > bestScore Then bestScore = boxHits(relC): best = relC
    Next relC
    descRelCol = best

    'Color column = most text+blank pattern, excluding desc column
    best = 1: bestScore = -1
    For relC = 1 To maxCols
        If relC <> descRelCol Then
            If (textHits(relC) + blankHits(relC)) > bestScore Then
                bestScore = (textHits(relC) + blankHits(relC))
                best = relC
            End If
        End If
    Next relC
    colorRelCol = best
End Sub

'===== Boxes_Shipped_Forecast SUB =====

Sub Boxes_Shipped_Forecast()

'==================== ALL DECLARATIONS ====================

    Dim oldCalc As XlCalculation

    'Assumptions + mapping
    Dim wsA As Worksheet
    Dim lo As ListObject
    Dim idxWs As Long, idxCountry As Long
    Dim idxPartner1 As Long, idxPartner2 As Long, idxAlloc As Long

    'Partner maps + allocation map
    Dim p1Map As Object, p2Map As Object, allocMap As Object
    Dim mapKey As String
    Dim wsName As String, p1WsName As String, p2WsName As String
    Dim rP As Long

    'Forecast window
    Dim forecastStart As Date
    Dim forecastCutoff As Date

    'Config lists
    Dim colors As Collection
    Dim isOptional() As Boolean

    'Debug sheet / headers
    Dim wsDebug As Worksheet
    Dim b As Long, hdrCol As Long
    Dim totalCols As Long
    Dim h As Long

    'Output buffer
    Dim outArr() As Variant
    Dim outCapacity As Long, outUsed As Long

    'Row loop
    Dim rMap As Long
    Dim c As Range ' (you currently declare this but never use it; keep or delete everywhere)
    Dim wsT As Worksheet

    'DO NOT use "Worksheet" as a variable name — rename it
    Dim sheetName As String   ' <- replaces your Dim Worksheet As String

    'Section tables + indexes
    Dim salesTbl As Range, begTbl As Range, endTbl As Range, poTbl As Range
    Dim salesIdx As Variant, begIdx As Variant, endIdx As Variant, poIdx As Variant
    Dim salesMap As Object, begMap As Object, poMap As Object
    
    'Arrays for fast reads (per sheet)
    Dim salesArr As Variant, begArr As Variant, poArr As Variant
    Dim salesFirstCol As Long, begFirstCol As Long, poFirstCol As Long
    Dim salesFirstRow As Long, begFirstRow As Long, poFirstRow As Long
    Dim colRelSales As Long, colRelBeg As Long, colRelPO As Long

    'Forecast column scan
    Dim startCol As Long, lastCol As Long, col As Long
    Dim colLetter As String

    'Color loop + need array
    Dim i As Long
    Dim need() As Double
    Dim needCache As Object
    Dim needByColor As Object          
    Dim needTmp() As Double
    Dim vNeed As Variant

    'Row write helpers
    Dim writeCol As Long
    Dim rr As Long
    Dim key As String
    Dim begCol As Long, ibCol As Long
    Dim sumAvail As Double
    Dim begVal As Double

    'Shared business keys used everywhere
    Dim demandCity As String
    Dim country As String
    Dim colorKey As String

    '==================== COLUMN STARTS ====================
    Dim COL_SALES As Long, COL_BEG As Long, COL_IB As Long, COL_AVAIL As Long, COL_BACKLOG As Long
    Dim COL_NEED As Long
    Dim COL_ORD_BL_AVAIL As Long, COL_ORD_BL_BACKLOG As Long, COL_ORD_BL_SHIP As Long
    Dim COL_BL_SHIP As Long, COL_AVAIL_POSTBL As Long
    Dim COL_ORD_SALES_AVAIL As Long, COL_ORD_SALES_DEMAND As Long, COL_ORD_SALES_SHIP As Long
    Dim COL_SALES_SHIP As Long, COL_AVAIL_POSTSALES As Long

    '==================== WEEK ENGINE INDEXING ====================
    Dim rowLookup As Object
    Dim rrLocal As Long, rrPrev As Long
    Dim keyLocal As String, keyPrev As String

    Dim weekDict As Object
    Dim wkDate As Date, wkKey As String
    Dim weeks() As Date, wkCount As Long, iWk As Long
    Dim tmpK As Variant, idx As Long
    Dim a As Long, j As Long
    Dim t As Date
    Dim wkStart As Date
    Dim needVal As Double

    'Local round computations
    Dim ordersFromAvail As Double, ordersFromBacklog As Double, ordersShipped_Backlog As Double
    Dim ordersFromAvail2 As Double, ordersFromSales As Double, ordersShipped_Sales As Double
    Dim availVal As Double, backlogVal As Double, salesVal As Double

    Dim desiredBL As Double, shippedBL As Double, availPost As Double, blP1 As Double
    Dim desiredS As Double, shippedS As Double, availPostSales As Double, sP1 As Double
    Dim baselineBL As Double, prevUnf As Double

    'P1 fill + passes
    Dim rrP1 As Long
    Dim p1City As String, keyP1 As String

    Dim ordersFromAvailP1 As Double
    Dim ordersFromBacklogP1 As Double
    Dim ordersShipped_BacklogP1 As Double
    Dim p1AvailVal As Double, blP1Val As Double
    Dim needValP1Orders As Double

    Dim p1BacklogTotals As Object
    Dim kTot As String
    Dim totVal As Double
    Dim shortfallP1 As Double

    Dim ordersShippedP1 As Double
    Dim needValP1 As Double
    Dim shippedP1 As Double
    Dim p1AvailPostLocalVal As Double
    Dim p1AvailPostBacklogVal As Double
    Dim blP1BoxVal As Double
    Dim blP2Val As Double
    Dim desiredP1 As Double

    Dim ordersFromAvailSalesP1 As Double
    Dim ordersFromSalesP1 As Double
    Dim ordersShipped_SalesP1 As Double
    Dim p1AvailPostBL_Val As Double, salesP1Val_Box As Double
    Dim needValSalesP1 As Double

    Dim p1SalesTotals As Object
    Dim kSalesTot As String
    Dim totSalesVal As Double
    Dim shortfallSales As Double

    Dim ordersShippedSalesP1 As Double
    Dim desiredSalesShipP1 As Double
    Dim shippedSalesP1 As Double
    Dim p1AvailPostBL_Box As Double
    Dim p1AvailPostSales_Box As Double
    Dim salesP2_Box As Double
    Dim needValShip As Double

    'P2 fill + passes
    Dim p1CityRow As Object
    Dim kP1City As String

    Dim p2City As String
    Dim kP2City As String
    Dim rrRep As Long
    Dim rrP2Local As Long

    Dim ordersFromAvailP2 As Double
    Dim ordersFromBacklogP2 As Double
    Dim ordersShipped_BacklogP2 As Double
    Dim p2AvailVal As Double, blP2BoxVal As Double, needValP2 As Double

    Dim p2BacklogTotals As Object
    Dim p2TotKey As String
    Dim totP2BL As Double
    Dim shortfallP2BL As Double

    Dim ordersShippedP2BL As Double
    Dim desiredP2BL As Double
    Dim shippedP2BL As Double
    Dim p2AvailStart As Double
    Dim p2AvailAfterBL As Double
    Dim blUnf As Double

    Dim ordersFromAvailSalesP2 As Double
    Dim ordersFromSalesP2 As Double
    Dim ordersShipped_SalesP2 As Double
    Dim p2AvailPostBL_Box As Double, salesP2Val_Box As Double, needValSalesP2 As Double

    Dim p2SalesTotals As Object
    Dim p2SalesKey As String
    Dim totP2Sales As Double
    Dim shortfallP2Sales As Double

    Dim ordersShippedP2Sales As Double
    Dim desiredP2Sales As Double
    Dim shippedP2Sales As Double
    Dim p2AvailPostSales_Box As Double
    Dim salesUnf As Double

    Dim unf As Double

    'Post-pass 16 rollups
    Dim sumBL_Local As Double, sumSales_Local As Double
    Dim sumBL_P1 As Double, sumSales_P1 As Double
    Dim sumBL_P2 As Double, sumSales_P2 As Double

    'Post-pass 17 outbound totals
    Dim outboundTotals As Object
    Dim kOut As String
    Dim demandC As String, countryC As String, colorC As String, wkC As String
    Dim p1C As String, p2C As String
    Dim shippedLocal As Double, shippedFromP1 As Double, shippedFromP2 As Double

    '==================== END DECLARATIONS ====================

    oldCalc = Application.Calculation
    
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.Calculation = xlCalculationManual
    Application.DisplayStatusBar = True

    InitConfig

    Set wsA = ThisWorkbook.Worksheets(CFG_ASSUMPTIONS_SHEET)

    'Worksheet mapping table: find by headers (Worksheet + Country), name can vary
    Set lo = FindTableByHeaders(Array("Worksheet", "Country"), CFG_TABLE_WORKSHEETS_PREFERRED)
    If lo Is Nothing Then
        MsgBox "Could not find worksheet mapping table (needs columns like Worksheet/Sheet and Country/Market).", vbExclamation
        Exit Sub
    End If

    idxWs = GetListColumnIndexByAliases(lo, CFG_WORKSHEET_HEADERS)
    idxCountry = GetListColumnIndexByAliases(lo, CFG_COUNTRY_HEADERS)
    If idxWs = 0 Or idxCountry = 0 Then
        MsgBox "Worksheet mapping table found, but could not resolve Worksheet/Country columns by aliases.", vbExclamation
        Exit Sub
    End If

    '=== Build Partner City 1 lookup map from WorksheetNames ===
    idxPartner1 = GetListColumnIndexByAliases(lo, Array("Partner City 1", "PartnerCity1", "P1", "P1 City"))
    
    If idxPartner1 = 0 Then
        MsgBox "WorksheetNames table found, but could not find column 'Partner City 1'.", vbExclamation
        Exit Sub
    End If
    
    Set p1Map = MapCreate()
    
    For rP = 1 To lo.DataBodyRange.Rows.Count
        wsName = Trim$(CStr(lo.DataBodyRange.Cells(rP, idxWs).value))
        p1WsName = Trim$(CStr(lo.DataBodyRange.Cells(rP, idxPartner1).value))
    
        If Len(wsName) > 0 And Len(p1WsName) > 0 Then
            mapKey = Trim$(CStr(lo.DataBodyRange.Cells(rP, idxCountry).value)) & "|" & wsName
            MapAddFirst p1Map, mapKey, p1WsName
        End If
    Next rP
    
    '=== Build Partner City 2 lookup map from WorksheetNames ===
    idxPartner2 = GetListColumnIndexByAliases(lo, Array("Partner City 2", "PartnerCity2", "P2", "P2 City"))
    
    If idxPartner2 = 0 Then
        MsgBox "WorksheetNames table found, but could not find column 'Partner City 2'.", vbExclamation
        Exit Sub
    End If
    
    Set p2Map = MapCreate()
    
    For rP = 1 To lo.DataBodyRange.Rows.Count
        wsName = Trim$(CStr(lo.DataBodyRange.Cells(rP, idxWs).value))
        p2WsName = Trim$(CStr(lo.DataBodyRange.Cells(rP, idxPartner2).value))
    
        If Len(wsName) > 0 And Len(p2WsName) > 0 Then
            mapKey = Trim$(CStr(lo.DataBodyRange.Cells(rP, idxCountry).value)) & "|" & wsName
            MapAddFirst p2Map, mapKey, p2WsName
        End If
    Next rP

    '=== Build Allocation lookup map from WorksheetNames ===
    'Key: Country|Worksheet (e.g., "USA|Neptune-Moreno") -> Double share (e.g., 0.35)
    idxAlloc = GetListColumnIndexByAliases(lo, Array("Allocation", "Alloc", "Share"))
    If idxAlloc = 0 Then
        MsgBox "WorksheetNames table found, but could not find column 'Allocation'.", vbExclamation
        Exit Sub
    End If
    
    Set allocMap = MapCreate()
    
    Dim rawAlloc As Variant, allocShare As Double
    For rP = 1 To lo.DataBodyRange.Rows.Count
    
        wsName = Trim$(CStr(lo.DataBodyRange.Cells(rP, idxWs).Value))
        If Len(wsName) = 0 Then GoTo NextAllocRow
    
        mapKey = Trim$(CStr(lo.DataBodyRange.Cells(rP, idxCountry).Value)) & "|" & wsName
    
        rawAlloc = lo.DataBodyRange.Cells(rP, idxAlloc).Value
    
        'Excel may store 35% as 0.35 (numeric) or as "35%" (string).
        If IsNumeric(rawAlloc) Then
            allocShare = CDbl(rawAlloc)
        Else
            allocShare = Val(CStr(rawAlloc)) / 100#
        End If
    
        'If user typed 35 (not 35%), treat as 35%
        If allocShare > 1# Then allocShare = allocShare / 100#
    
        MapSet allocMap, mapKey, allocShare
    
    NextAllocRow:
    Next rP


    '=== Forecast start date from assumptions ===
     forecastStart = CDate(wsA.Range(CFG_FORECAST_START_CELL).value)

    '=== Only run 1 year forward ===
    forecastCutoff = DateAdd("yyyy", 1, forecastStart)   'example: 2025-12-08 -> 2026-12-08, if we want 6 months instead of 1 year of forecast, change this line to: forecastCutoff = DateAdd("m", 6, forecastStart)

    '=== Active colors list from table "Colors" (Status = Active) ===
    Set colors = GetActiveColors_Configured()

    If colors.Count = 0 Then
            MsgBox "No Active colors found in table 'Colors'.", vbExclamation
            Exit Sub
        End If
    
        '=== MAX_BOX driven by table "Boxes" row count (data rows only) ===
        MAX_BOX = GetBoxCount_Configured()
        If MAX_BOX <= 0 Then
            MsgBox "Table 'Boxes' not found or has no rows.", vbExclamation
            Exit Sub
        End If
    
        isOptional = GetIsOptionalByBox_Configured(MAX_BOX)
    
    '==================== Build NEED cache once ====================
    Set needCache = MapCreate()
    
    Dim loColors As ListObject
    Set loColors = FindTableByHeaders(Array("Color", "Status"), CFG_TABLE_COLORS_PREFERRED)
    
    If Not loColors Is Nothing Then
    
        Dim idxNeedColor As Long
        idxNeedColor = GetListColumnIndexByAliases(loColors, CFG_COLOR_HEADERS)
    
        If idxNeedColor > 0 And Not loColors.DataBodyRange Is Nothing Then
    
            'Pre-resolve Box column indexes ONCE (Box 1..MAX_BOX)
            Dim boxColIdx() As Long
            Dim bNeed As Long
            ReDim boxColIdx(1 To MAX_BOX)
    
            For bNeed = 1 To MAX_BOX
                boxColIdx(bNeed) = GetListColumnIndexByAliases(loColors, Array("Box " & bNeed))
            Next bNeed
    
            Dim rNeed As Long
            Dim clrNeed As String, keyNeed As String
            Dim rawNeed As Variant, valNeed As Double
    
            For rNeed = 1 To loColors.DataBodyRange.Rows.Count
    
                clrNeed = NormalizeColor(CStr(loColors.DataBodyRange.Cells(rNeed, idxNeedColor).Value))
                If Len(clrNeed) = 0 Then GoTo NextNeedRow
    
                For bNeed = 1 To MAX_BOX
                    If boxColIdx(bNeed) > 0 Then
                        rawNeed = loColors.DataBodyRange.Cells(rNeed, boxColIdx(bNeed)).Value
                        valNeed = CDbl(Val(rawNeed))   'blank/non-numeric -> 0
                    Else
                        valNeed = 0#
                    End If
    
                    keyNeed = clrNeed & "|" & CStr(bNeed)
                    MapSet needCache, keyNeed, valNeed
                Next bNeed
    
    NextNeedRow:
            Next rNeed
    
        End If
    End If

    '==================== Prebuild Need arrays per color (speed) ====================
    Set needByColor = MapCreate()
    
    Dim cKey As String
    Dim nb As Long
    
    For i = 1 To colors.Count
        cKey = NormalizeColor(colors(i))
        ReDim needTmp(1 To MAX_BOX)
        For nb = 1 To MAX_BOX
            needTmp(nb) = MapGetDouble(needCache, cKey & "|" & CStr(nb), 0#)
        Next nb
        'store the whole array as a Variant
        MapSet needByColor, cKey, needTmp
    Next i

    '==================== Working variables (declared once) ====================
    
    'Column index helpers used in Round 1/2 calculations
    Dim availCol As Long, backlogCol As Long, backlogShippedCol As Long
    Dim salesCol As Long, availPostBacklogCol As Long, salesShippedCol As Long
                          
    '=== Set up / create the Debug sheet and the output row counter ===
    On Error Resume Next
    Set wsDebug = ThisWorkbook.Worksheets("Boxes_Shipped_DEBUG")
    On Error GoTo 0
    
    If wsDebug Is Nothing Then
        Set wsDebug = ThisWorkbook.Worksheets.Add(After:=ThisWorkbook.Worksheets(ThisWorkbook.Worksheets.Count))
        wsDebug.Name = "Boxes_Shipped_DEBUG"
    End If
    
    wsDebug.Cells.Clear
    wsDebug.Range("A1").value = "Demand City"
    wsDebug.Range("B1").value = "Country"
    wsDebug.Range("C1").value = "Color"
    wsDebug.Range("D1").value = "Week Start"
    wsDebug.Range("E1").value = "Week End"
    wsDebug.Range("F1").value = "Col"

    '=== NEW: Add box columns ===
    hdrCol = 7 ' Column G = first new header

    '--- Sales B1..Bn ---
    COL_SALES = hdrCol
    For b = 1 To MAX_BOX
        wsDebug.Cells(1, hdrCol).value = "Sales B" & b
        hdrCol = hdrCol + 1
    Next b

    '--- Beg Stock B1..Bn ---
    COL_BEG = hdrCol
    For b = 1 To MAX_BOX
        wsDebug.Cells(1, hdrCol).value = "Beg Stock B" & b
        hdrCol = hdrCol + 1
    Next b

    '--- IB B1..Bn ---
    COL_IB = hdrCol
    For b = 1 To MAX_BOX
        wsDebug.Cells(1, hdrCol).value = "IB B" & b
        hdrCol = hdrCol + 1
    Next b

    '--- AvailStock B1..Bn ---
    COL_AVAIL = hdrCol
    For b = 1 To MAX_BOX
        wsDebug.Cells(1, hdrCol).value = "AvailStock B" & b
        hdrCol = hdrCol + 1
    Next b

    '--- Backlog B1..Bn ---
    COL_BACKLOG = hdrCol
    For b = 1 To MAX_BOX
        wsDebug.Cells(1, hdrCol).value = "Backlog B" & b
        hdrCol = hdrCol + 1
    Next b

    '--- Need B1..Bn ---
    COL_NEED = hdrCol
    For b = 1 To MAX_BOX
        wsDebug.Cells(1, hdrCol).value = "Need B" & b
        hdrCol = hdrCol + 1
    Next b

    '--- Backlog orders debug (3 columns) ---
    COL_ORD_BL_AVAIL = hdrCol
    wsDebug.Cells(1, hdrCol).value = "Orders_Backlog_LimitByAvail"
    hdrCol = hdrCol + 1

    COL_ORD_BL_BACKLOG = hdrCol
    wsDebug.Cells(1, hdrCol).value = "Orders_Backlog_LimitByBacklog"
    hdrCol = hdrCol + 1

    COL_ORD_BL_SHIP = hdrCol
    wsDebug.Cells(1, hdrCol).value = "OrdersShipped_Backlog"
    hdrCol = hdrCol + 1

    '--- BacklogShipped B1..Bn ---
    COL_BL_SHIP = hdrCol
    For b = 1 To MAX_BOX
        wsDebug.Cells(1, hdrCol).value = "BacklogShipped B" & b
        hdrCol = hdrCol + 1
    Next b

    '--- AvailStock_PostBacklog B1..Bn ---
    COL_AVAIL_POSTBL = hdrCol
    For b = 1 To MAX_BOX
        wsDebug.Cells(1, hdrCol).value = "AvailStock_PostBacklog B" & b
        hdrCol = hdrCol + 1
    Next b

    '--- Sales orders debug (3 columns) ---
    COL_ORD_SALES_AVAIL = hdrCol
    wsDebug.Cells(1, hdrCol).value = "Orders_Sales_LimitByAvail"
    hdrCol = hdrCol + 1

    COL_ORD_SALES_DEMAND = hdrCol
    wsDebug.Cells(1, hdrCol).value = "Orders_Sales_LimitBySales"
    hdrCol = hdrCol + 1

    COL_ORD_SALES_SHIP = hdrCol
    wsDebug.Cells(1, hdrCol).value = "OrdersShipped_Sales"
    hdrCol = hdrCol + 1

    '--- SalesShipped B1..Bn ---
    COL_SALES_SHIP = hdrCol
    For b = 1 To MAX_BOX
        wsDebug.Cells(1, hdrCol).value = "SalesShipped B" & b
        hdrCol = hdrCol + 1
    Next b

    '=== FINAL column count (A..last header) ===
    totalCols = hdrCol - 1   'hdrCol is the NEXT empty column
    
    '=== Output buffer (write once at the end) ===
    outCapacity = 50000
    ReDim outArr(1 To outCapacity, 1 To totalCols)
    
    '=== Copy headers into outArr row 1 ===
    For h = 1 To totalCols
        outArr(1, h) = wsDebug.Cells(1, h).value
    Next h
    
    'We will NOT write row-by-row to the sheet anymore.
    'We'll fill outArr, then dump it at the end.

    'Row 1 in outArr is headers. Data starts at row 2.
    outUsed = 1
    
    For rMap = 1 To lo.DataBodyRange.Rows.Count

        sheetName = Trim$(CStr(lo.DataBodyRange.Cells(rMap, idxWs).value))
        If Len(sheetName) = 0 Then GoTo NextOne

        country = Trim$(CStr(lo.DataBodyRange.Cells(rMap, idxCountry).value))

        On Error Resume Next
        Set wsT = ThisWorkbook.Worksheets(sheetName)
        On Error GoTo 0
        
        If wsT Is Nothing Then
            Debug.Print "Missing sheet:", sheetName
        Else
            Debug.Print "Reading:", wsT.Name, "A1=", wsT.Range("A1").value

            demandCity = DemandCityFromSheetName(wsT.Name)

            '=== NEW: Build section tables (ranges) from column C headers ===
               
            Set salesTbl = BuildSectionTable_Block(wsT, "Sales")
            Set begTbl = BuildSectionTable_Block(wsT, "Beginning Stock")
            Set endTbl = BuildSectionTable_Block(wsT, "Ending Stock")
            Set poTbl = BuildSectionTable_Block(wsT, "POs to be received")

            '=== Load section blocks into arrays once (FAST) ===
            If Not salesTbl Is Nothing Then
                salesArr = salesTbl.Value2
                salesFirstCol = salesTbl.Column
                salesFirstRow = salesTbl.Row
            End If
            
            If Not begTbl Is Nothing Then
                begArr = begTbl.Value2
                begFirstCol = begTbl.Column
                begFirstRow = begTbl.Row
            End If
            
            If Not poTbl Is Nothing Then
                poArr = poTbl.Value2
                poFirstCol = poTbl.Column
                poFirstRow = poTbl.Row
            End If

            'Optional: quick debug if any section is missing
            If salesTbl Is Nothing Then Debug.Print wsT.Name & ": Missing section 'Sales'"
            If begTbl Is Nothing Then Debug.Print wsT.Name & ": Missing section 'Beginning Stock'"
            If endTbl Is Nothing Then Debug.Print wsT.Name & ": Missing section 'Ending Stock'"
            If poTbl Is Nothing Then Debug.Print wsT.Name & ": Missing section 'POs to be received'"

            '=== Build section INDEX tables (Color+Box -> Row) ===
               
            salesIdx = BuildSectionIndex_FromRange(salesTbl)
            begIdx = BuildSectionIndex_FromRange(begTbl)
            endIdx = BuildSectionIndex_FromRange(endTbl)
            poIdx = BuildSectionIndex_FromRange(poTbl)

            '=== FAST MAPS (Color|Box -> Row) to avoid scanning arrays repeatedly ===
            Set salesMap = BuildRowMap(salesIdx)
            Set begMap = BuildRowMap(begIdx)
            Set poMap = BuildRowMap(poIdx)
            
            '=== Find the forecast start column on row 2 (match forecastStart) ===
            startCol = 0
            
            lastCol = wsT.Cells(2, wsT.Columns.Count).End(xlToLeft).Column
            
            For col = 1 To lastCol
                If IsDate(wsT.Cells(2, col).value) Then
                    If DateValue(wsT.Cells(2, col).value) = DateValue(forecastStart) Then
                        startCol = col
                        Exit For
                    End If
                End If
            Next col
            
            If startCol = 0 Then
                Debug.Print "Forecast start date not found on row 2 for sheet:", wsT.Name, "Start:", Format(forecastStart, "yyyy-mm-dd")
            Else
                '=== Loop week columns from forecastStart onward ===
                For col = startCol To lastCol
                    If Not IsDate(wsT.Cells(2, col).value) Then Exit For
                
                    '=== Stop once Week Start is at/after the cutoff ===
                    If DateValue(wsT.Cells(2, col).value) >= DateValue(forecastCutoff) Then Exit For
                    
                    colLetter = Split(wsT.Cells(1, col).Address(False, False), "1")(0)

                    For i = 1 To colors.Count
                        
                        colorKey = NormalizeColor(colors(i))  ' make sure it matches index normalization

                       '=== Load "need per order" from CACHE (Box 1..MAX_BOX) ===
                        ReDim need(1 To MAX_BOX)
                        
                        'Pull prebuilt need array for this color (FAST)
                        vNeed = MapGetVariant(needByColor, colorKey, Empty)
                        If IsEmpty(vNeed) Then
                            ReDim need(1 To MAX_BOX)
                            'fallback (should be rare)
                            For b = 1 To MAX_BOX
                                need(b) = MapGetDouble(needCache, colorKey & "|" & CStr(b), 0#)
                            Next b
                        Else
                            need = vNeed   'assign Double() array
                        End If

                        'Advance output row (into the array)
                        outUsed = outUsed + 1
                        If outUsed > outCapacity Then
                            outCapacity = outCapacity + 50000
                            ReDim Preserve outArr(1 To outCapacity, 1 To totalCols)
                        End If
                        
                        'Write columns A:F into the array
                        outArr(outUsed, 1) = demandCity
                        outArr(outUsed, 2) = country
                        outArr(outUsed, 3) = colors(i)
                        outArr(outUsed, 4) = wsT.Cells(2, col).value
                        outArr(outUsed, 5) = wsT.Cells(4, col).value
                        outArr(outUsed, 6) = colLetter
                        
                    
                        '=== NEW: populate Sales / Beginning Stock / Inbound for each box ===
                         writeCol = COL_SALES
                                              
                        '--- Sales B1..Bn ---
                        'Compute column-relative index once
                        colRelSales = col - salesFirstCol + 1
                        
                        For b = 1 To MAX_BOX
                            key = colorKey & "|" & CStr(b)
                        
                            rr = MapGetLong(salesMap, key, 0) 'rr is RELATIVE row now
                            If rr > 0 Then
                                outArr(outUsed, writeCol) = salesArr(rr, colRelSales)
                            Else
                                outArr(outUsed, writeCol) = 0
                            End If
                        
                            writeCol = writeCol + 1
                        Next b
                    
                        '--- Beginning Stock B1..Bn ---
                        colRelBeg = col - begFirstCol + 1

                        For b = 1 To MAX_BOX
                            key = colorKey & "|" & CStr(b)
                        
                            rr = MapGetLong(begMap, key, 0)
                            If rr > 0 Then
                                outArr(outUsed, writeCol) = begArr(rr, colRelBeg)
                            Else
                                outArr(outUsed, writeCol) = 0
                            End If
                        
                            writeCol = writeCol + 1
                        Next b

                        '--- Inbound B1..Bn (POs to be received) ---
                        colRelPO = col - poFirstCol + 1
                        
                        For b = 1 To MAX_BOX
                            key = colorKey & "|" & CStr(b)
                        
                            rr = MapGetLong(poMap, key, 0)
                            If rr > 0 Then
                                outArr(outUsed, writeCol) = poArr(rr, colRelPO)
                            Else
                                outArr(outUsed, writeCol) = 0
                            End If
                        
                            writeCol = writeCol + 1
                        Next b

                        '--- AvailStock B1..Bn = MAX(0, Beg Stock + IB) ---
                        For b = 1 To MAX_BOX
                            begCol = COL_BEG + (b - 1)         'Beg Stock block starts after Sales
                            ibCol = COL_IB + (b - 1)    'IB block starts after Sales+Beg
                        
                            sumAvail = CDbl(outArr(outUsed, begCol)) + CDbl(outArr(outUsed, ibCol))

                            If sumAvail < 0 Then
                                outArr(outUsed, writeCol) = 0
                            Else
                                outArr(outUsed, writeCol) = sumAvail
                            End If

                        
                            writeCol = writeCol + 1
                        Next b

                       '--- Backlog B1..Bn (TEMP = baseline backlog from Beg Stock; rolling backlog applied later) ---
                        For b = 1 To MAX_BOX
                            begCol = COL_BEG + (b - 1)
                        
                            begVal = CDbl(outArr(outUsed, begCol))
                            If begVal < 0 Then
                                outArr(outUsed, writeCol) = Abs(begVal)   'baseline backlog
                            Else
                                outArr(outUsed, writeCol) = 0
                            End If
                        
                            writeCol = writeCol + 1
                        Next b

                        '=== Write Need B1..Bn into the output row ===
                        For b = 1 To MAX_BOX
                            outArr(outUsed, writeCol) = need(b)
                            writeCol = writeCol + 1
                        Next b

                        '=== INIT (Local rounds now computed later in week-by-week pass) ===
                        outArr(outUsed, COL_ORD_BL_AVAIL) = 0
                        outArr(outUsed, COL_ORD_BL_BACKLOG) = 0
                        outArr(outUsed, COL_ORD_BL_SHIP) = 0
                        
                        outArr(outUsed, COL_ORD_SALES_AVAIL) = 0
                        outArr(outUsed, COL_ORD_SALES_DEMAND) = 0
                        outArr(outUsed, COL_ORD_SALES_SHIP) = 0
                        
                        For b = 1 To MAX_BOX
                            outArr(outUsed, COL_BL_SHIP + (b - 1)) = 0
                            outArr(outUsed, COL_AVAIL_POSTBL + (b - 1)) = 0
                            outArr(outUsed, COL_SALES_SHIP + (b - 1)) = 0
                        Next b

                    Next i
                Next col
            End If
        End If
        
NextOne:
        Set wsT = Nothing
    Next rMap

'==================== WEEK-BY-WEEK ENGINE (replaces POST-PASS 1..15) =====================

Set rowLookup = MapCreate()

'Index every row by DemandCity|Country|Color|WeekStart
For rrLocal = 2 To outUsed
    keyLocal = CStr(outArr(rrLocal, 1)) & "|" & _
               CStr(outArr(rrLocal, 2)) & "|" & _
               NormalizeColor(CStr(outArr(rrLocal, 3))) & "|" & _
               Format$(CDate(outArr(rrLocal, 4)), "yyyy-mm-dd")

    MapAddFirst rowLookup, keyLocal, rrLocal

Next rrLocal

'--- Build sorted unique list of WeekStart dates present in outArr ---
Set weekDict = MapCreate()

For rrLocal = 2 To outUsed
    wkDate = CDate(outArr(rrLocal, 4))
    wkKey = Format$(wkDate, "yyyy-mm-dd")
    MapAddFirst weekDict, wkKey, wkDate
Next rrLocal

wkCount = MapCount(weekDict)
ReDim weeks(1 To wkCount)

idx = 0
Dim wkKeys As Variant
wkKeys = MapKeys(weekDict)

For Each tmpK In wkKeys
    idx = idx + 1
    weeks(idx) = CDate(MapGetVariant(weekDict, CStr(tmpK), 0))
Next tmpK


'Sort weeks ascending (simple bubble; wkCount is small ~52)
For a = 1 To wkCount - 1
    For j = a + 1 To wkCount
        If weeks(j) < weeks(a) Then
            t = weeks(a)
            weeks(a) = weeks(j)
            weeks(j) = t
        End If
    Next j
Next a

'Process each week in chronological order
For iWk = 1 To wkCount

    wkStart = weeks(iWk)

    '==================== 1) Compute Rolling Backlog for this week =====================
    For rrLocal = 2 To outUsed

        If DateValue(CDate(outArr(rrLocal, 4))) <> DateValue(wkStart) Then GoTo NextRow_Backlog

        demandCity = Trim$(CStr(outArr(rrLocal, 1)))
        country = Trim$(CStr(outArr(rrLocal, 2)))
        colorKey = NormalizeColor(CStr(outArr(rrLocal, 3)))

        'previous week key (assumes weekly cadence = -7 days)
        'keyPrev = demandCity & "|" & country & "|" & colorKey & "|" & Format$(DateAdd("d", -7, wkStart), "yyyy-mm-dd")

        For b = 1 To MAX_BOX

            'baseline backlog from Beg Stock
            begVal = CDbl(outArr(rrLocal, COL_BEG + (b - 1)))
            If begVal < 0 Then baselineBL = Abs(begVal) Else baselineBL = 0

           
            'Backlog is ALWAYS baseline backlog (no rolling)
            outArr(rrLocal, COL_BACKLOG + (b - 1)) = baselineBL
        Next b

NextRow_Backlog:
    Next rrLocal

    '==================== 2) Local Round: Backlog-first =====================
    For rrLocal = 2 To outUsed

        If DateValue(CDate(outArr(rrLocal, 4))) <> DateValue(wkStart) Then GoTo NextRow_LocalBL

        ordersFromAvail = 1E+30
        ordersFromBacklog = 1E+30

        For b = 1 To MAX_BOX
            If Not isOptional(b) Then
                availVal = CDbl(outArr(rrLocal, COL_AVAIL + (b - 1)))
                backlogVal = CDbl(outArr(rrLocal, COL_BACKLOG + (b - 1)))
                needVal = CDbl(outArr(rrLocal, COL_NEED + (b - 1)))
                If needVal <= 0 Then needVal = 1

                ordersFromAvail = MinD(ordersFromAvail, OrdersFromQty(availVal, needVal))
                ordersFromBacklog = MinD(ordersFromBacklog, OrdersFromQty(backlogVal, needVal))
            End If
        Next b

        If ordersFromAvail = 1E+30 Then ordersFromAvail = 0
        If ordersFromBacklog = 1E+30 Then ordersFromBacklog = 0

        ordersShipped_Backlog = MinD(ordersFromAvail, ordersFromBacklog)

        outArr(rrLocal, COL_ORD_BL_AVAIL) = WorksheetFunction.Round(ordersFromAvail, 2)
        outArr(rrLocal, COL_ORD_BL_BACKLOG) = WorksheetFunction.Round(ordersFromBacklog, 2)
        outArr(rrLocal, COL_ORD_BL_SHIP) = WorksheetFunction.Round(ordersShipped_Backlog, 2)

        'BacklogShipped + AvailPostBL + Backlog_P1
        For b = 1 To MAX_BOX

            needVal = CDbl(outArr(rrLocal, COL_NEED + (b - 1)))
            If needVal <= 0 Then needVal = 1

            desiredBL = ordersShipped_Backlog * needVal

            If isOptional(b) Then
                availVal = CDbl(outArr(rrLocal, COL_AVAIL + (b - 1)))
                shippedBL = MinD(availVal, desiredBL)
            Else
                shippedBL = desiredBL
            End If

            outArr(rrLocal, COL_BL_SHIP + (b - 1)) = shippedBL

            availPost = CDbl(outArr(rrLocal, COL_AVAIL + (b - 1))) - shippedBL
            If availPost < 0 Then availPost = 0
            outArr(rrLocal, COL_AVAIL_POSTBL + (b - 1)) = availPost

        Next b

NextRow_LocalBL:
    Next rrLocal

    '==================== 3) Local Round: Sales-after-backlog =====================
    For rrLocal = 2 To outUsed

        If DateValue(CDate(outArr(rrLocal, 4))) <> DateValue(wkStart) Then GoTo NextRow_LocalSales

        ordersFromAvail2 = 1E+30
        ordersFromSales = 1E+30

        For b = 1 To MAX_BOX
            If Not isOptional(b) Then
                salesVal = CDbl(outArr(rrLocal, COL_SALES + (b - 1)))
                availVal = CDbl(outArr(rrLocal, COL_AVAIL_POSTBL + (b - 1)))
                needVal = CDbl(outArr(rrLocal, COL_NEED + (b - 1)))
                If needVal <= 0 Then needVal = 1

                ordersFromAvail2 = MinD(ordersFromAvail2, OrdersFromQty(availVal, needVal))
                ordersFromSales = MinD(ordersFromSales, OrdersFromQty(salesVal, needVal))
            End If
        Next b

        If ordersFromAvail2 = 1E+30 Then ordersFromAvail2 = 0
        If ordersFromSales = 1E+30 Then ordersFromSales = 0

        ordersShipped_Sales = MinD(ordersFromAvail2, ordersFromSales)

        outArr(rrLocal, COL_ORD_SALES_AVAIL) = WorksheetFunction.Round(ordersFromAvail2, 2)
        outArr(rrLocal, COL_ORD_SALES_DEMAND) = WorksheetFunction.Round(ordersFromSales, 2)
        outArr(rrLocal, COL_ORD_SALES_SHIP) = WorksheetFunction.Round(ordersShipped_Sales, 2)

        For b = 1 To MAX_BOX

            needVal = CDbl(outArr(rrLocal, COL_NEED + (b - 1)))
            If needVal <= 0 Then needVal = 1

            desiredS = ordersShipped_Sales * needVal

            If isOptional(b) Then
                availVal = CDbl(outArr(rrLocal, COL_AVAIL_POSTBL + (b - 1)))
                shippedS = MinD(availVal, desiredS)
            Else
                shippedS = desiredS
            End If

            outArr(rrLocal, COL_SALES_SHIP + (b - 1)) = shippedS

        Next b

NextRow_LocalSales:
    Next rrLocal

  Next iWk

'==================== END WEEK-BY-WEEK ENGINE =====================

    '=== Build second debug sheet (City x Week x Color) ===
    Call Build_DebugSheet_CityWeekColor( _
        outArr, outUsed, _
        COL_ORD_BL_AVAIL, COL_ORD_BL_BACKLOG, _
        COL_ORD_SALES_AVAIL, COL_ORD_SALES_DEMAND, _
        allocMap)
    
    '=== NEW: Override OrdersShipped_Backlog using CityWeek totals, then recompute BacklogShipped/AvailPostBL/Sales ===
    Call Apply_BacklogOverride_FromCityWeek( _
        outArr, outUsed, _
        COL_ORD_BL_SHIP, _
        COL_AVAIL, COL_NEED, COL_BL_SHIP, COL_AVAIL_POSTBL, _
        COL_SALES, _
        COL_ORD_SALES_AVAIL, COL_ORD_SALES_DEMAND, COL_ORD_SALES_SHIP, _
        COL_SALES_SHIP, _
        MAX_BOX, isOptional)
    
    '=== Dump FINAL output array to Boxes_Shipped_DEBUG ===
    wsDebug.Range("A1").Resize(outUsed, totalCols).Value = outArr
    
    '=== Format only the used rows (fast) ===
    If outUsed >= 2 Then
        'wsDebug.Range(wsDebug.Cells(2, 7), wsDebug.Cells(outUsed, totalCols)).NumberFormat = "0"
        wsDebug.Range(wsDebug.Cells(2, 7), wsDebug.Cells(outUsed, totalCols)).NumberFormat = "0.00"
        'Show fractional orders (2 decimals) in the order-debug columns
        wsDebug.Range(wsDebug.Cells(2, COL_ORD_BL_AVAIL), wsDebug.Cells(outUsed, COL_ORD_BL_SHIP)).NumberFormat = "0.00"
        wsDebug.Range(wsDebug.Cells(2, COL_ORD_SALES_AVAIL), wsDebug.Cells(outUsed, COL_ORD_SALES_SHIP)).NumberFormat = "0.00"
        wsDebug.Range(wsDebug.Cells(2, 4), wsDebug.Cells(outUsed, 5)).NumberFormat = "yyyy-mm-dd"
    End If

    Application.Calculation = oldCalc
    Application.EnableEvents = True
    Application.ScreenUpdating = True
    Application.StatusBar = False

    MsgBox "Boxes Shipped Forecast Ran Successfully", vbInformation
End Sub

'=== City Name Mapping ===
Private Function DemandCityFromSheetName(ByVal sheetName As String) As String
    Select Case sheetName
        Case "Neptune-Montreal":  DemandCityFromSheetName = "Montreal"
        Case "Neptune-Vancouver": DemandCityFromSheetName = "Vancouver"
        Case "Neptune-Toronto":   DemandCityFromSheetName = "Toronto"
        Case "Neptune-Moreno":    DemandCityFromSheetName = "Moreno"
        Case "Neptune-Dayton":    DemandCityFromSheetName = "Dayton"
        Case Else
            DemandCityFromSheetName = "UNKNOWN (" & sheetName & ")"
    End Select
End Function

'=== Section Table Builder ===
'Finds a section header in column C (exact match),
'then returns the block of rows for that section down to the row before the next section header,
'and out to the last week-start date column (last date in row 2).
Private Function BuildSectionTable_Block(ByVal ws As Worksheet, ByVal sectionHeader As String) As Range
    Dim sectionCol As Long
    sectionCol = FindSectionHeaderColumn(ws)
    If sectionCol = 0 Then
        Set BuildSectionTable_Block = Nothing
        Exit Function
    End If

    Dim headerCell As Range
    Set headerCell = FindInColumnExact_Num(ws, sectionCol, sectionHeader)

    If headerCell Is Nothing Then
        Set BuildSectionTable_Block = Nothing
        Exit Function
    End If

    Dim startRow As Long
    startRow = headerCell.Row + 1

    'Find end row: stop right before next section header (or at last used row in sectionCol)
    Dim lastRow As Long
    lastRow = ws.Cells(ws.Rows.Count, sectionCol).End(xlUp).Row

    Dim r As Long, endRow As Long
    endRow = lastRow

    For r = startRow + 1 To lastRow
        If IsSectionHeader(ws.Cells(r, sectionCol).value) Then
            endRow = r - 1
            Exit For
        End If
    Next r

    'Rightmost column = last date in row 2
    Dim lastWeekCol As Long
    lastWeekCol = FindLastDateColumnInRow(ws, 2)
    If lastWeekCol = 0 Then lastWeekCol = ws.Range("E1").Column 'fallback

    'IMPORTANT: start the block at the *sectionCol* (not hard-coded "C")
    Set BuildSectionTable_Block = ws.Range(ws.Cells(startRow, sectionCol), ws.Cells(endRow, lastWeekCol))
End Function


'Helper: exact match search in a single column
Private Function FindInColumnExact(ByVal ws As Worksheet, ByVal colLetter As String, ByVal textToFind As String) As Range
    Dim lastRow As Long
    lastRow = ws.Cells(ws.Rows.Count, colLetter).End(xlUp).Row
    
    Dim r As Long
    For r = 1 To lastRow
        If UCase$(Trim$(CStr(ws.Cells(r, colLetter).value))) = UCase$(Trim$(textToFind)) Then
            Set FindInColumnExact = ws.Cells(r, colLetter)
            Exit Function
        End If
    Next r
    
    Set FindInColumnExact = Nothing
End Function

Private Function FindInColumnExact_Num(ByVal ws As Worksheet, ByVal colNum As Long, ByVal textToFind As String) As Range
    Dim lastRow As Long
    lastRow = ws.Cells(ws.Rows.Count, colNum).End(xlUp).Row

    Dim r As Long
    For r = 1 To lastRow
        If UCase$(Trim$(CStr(ws.Cells(r, colNum).value))) = UCase$(Trim$(textToFind)) Then
            Set FindInColumnExact_Num = ws.Cells(r, colNum)
            Exit Function
        End If
    Next r

    Set FindInColumnExact_Num = Nothing
End Function


'Helper: defines what counts as a section header in column C
Private Function IsSectionHeader(ByVal v As Variant) As Boolean
    Dim s As String: s = Trim$(CStr(v))
    If Len(s) = 0 Then Exit Function

    Dim lbl As Variant
    For Each lbl In CFG_SECTION_LABELS
        If StrComp(s, CStr(lbl), vbTextCompare) = 0 Then
            IsSectionHeader = True
            Exit Function
        End If
    Next lbl

    IsSectionHeader = False
End Function

'Returns the column number of the rightmost cell in a row that contains a date.
'If no date is found, returns 0.
Private Function FindLastDateColumnInRow(ByVal ws As Worksheet, ByVal rowNum As Long) As Long
    Dim lastCol As Long
    lastCol = ws.Cells(rowNum, ws.Columns.Count).End(xlToLeft).Column
    
    Dim c As Long
    For c = lastCol To 1 Step -1
        If IsDate(ws.Cells(rowNum, c).value) Then
            FindLastDateColumnInRow = c
            Exit Function
        End If
    Next c
    
    FindLastDateColumnInRow = 0
End Function

'Adds unique normalized colors found in column E of a section range.
'Implements fill-down: blank color cells inherit the most recent non-blank color above within that section scan.
Private Sub AddColorsFromSection(ByRef colors As Collection, ByVal sectionRng As Range)
    Dim descCol As Long, colorCol As Long
    GuessDescAndColorColumns sectionRng, descCol, colorCol

    Dim lastSeen As String
    lastSeen = ""

    Dim r As Long
    For r = 1 To sectionRng.Rows.Count
        Dim raw As String
        raw = Trim$(CStr(sectionRng.Cells(r, colorCol).value))

        If Len(raw) > 0 Then
            lastSeen = NormalizeColor(raw)
        ElseIf Len(lastSeen) > 0 Then
            'fill-down
        End If

        If Len(lastSeen) > 0 Then AddUniqueKeyed colors, lastSeen
    Next r
End Sub

'Normalize color strings so duplicates like " fog ", "FOG", "Fog" collapse to one key.
Private Function NormalizeColor(ByVal s As String) As String
    s = Trim$(s)
    If Len(s) = 0 Then
        NormalizeColor = ""
    Else
        NormalizeColor = UCase$(s)
    End If
End Function

'Cross-platform uniqueness using Collection keys (no Dictionary required).
Private Sub AddUniqueKeyed(ByRef col As Collection, ByVal key As String)
    On Error Resume Next
    col.Add key, key   'keyed add: duplicates throw error
    Err.Clear
    On Error GoTo 0
End Sub

Private Function GetActiveColors_Configured() As Collection
    Dim result As New Collection

    Dim lo As ListObject
    Set lo = FindTableByHeaders(Array("Color", "Status"), CFG_TABLE_COLORS_PREFERRED)
    If lo Is Nothing Then
        Set GetActiveColors_Configured = result
        Exit Function
    End If

    Dim idxColor As Long, idxStatus As Long
    idxColor = GetListColumnIndexByAliases(lo, CFG_COLOR_HEADERS)
    idxStatus = GetListColumnIndexByAliases(lo, CFG_STATUS_HEADERS)

    If idxColor = 0 Or idxStatus = 0 Then
        Set GetActiveColors_Configured = result
        Exit Function
    End If

    If lo.DataBodyRange Is Nothing Then
        Set GetActiveColors_Configured = result
        Exit Function
    End If

    Dim i As Long, statusVal As String, clr As String
    For i = 1 To lo.DataBodyRange.Rows.Count
        statusVal = Trim$(CStr(lo.DataBodyRange.Cells(i, idxStatus).value))

        If UCase$(statusVal) = "ACTIVE" Or UCase$(statusVal) = "TRUE" Or statusVal = "1" Then
            clr = NormalizeColor(CStr(lo.DataBodyRange.Cells(i, idxColor).value))
            If Len(clr) > 0 Then AddUniqueKeyed result, clr
        End If
    Next i

    Set GetActiveColors_Configured = result
End Function

Private Function GetBoxCount_Configured() As Long
    'Try preferred name first, else any table with at least one column and a DataBodyRange.
    'If you have a known header in Boxes table (recommended), swap this to FindTableByHeaders.
    Dim ws As Worksheet, lo As ListObject

    For Each ws In ThisWorkbook.Worksheets
        On Error Resume Next
        Set lo = ws.ListObjects(CFG_TABLE_BOXES_PREFERRED)
        On Error GoTo 0
        If Not lo Is Nothing Then Exit For
    Next ws

    If lo Is Nothing Then
        'Fallback: if table renamed, pick the first table named like "Boxes" is not possible reliably
        'Better: make Boxes table have a known header e.g. "Box" and use FindTableByHeaders(Array("Box"))
        GetBoxCount_Configured = 0
        Exit Function
    End If

    If lo.DataBodyRange Is Nothing Then
        GetBoxCount_Configured = 0
    Else
        GetBoxCount_Configured = lo.DataBodyRange.Rows.Count
    End If
End Function


'Returns a UNIQUE list of colors from a ListObject table where Status = "Active".
'TableName: name of the Excel table (ListObject), e.g. "Colors"
'ColorColName: header name for the color column, e.g. "Colors"
'StatusColName: header name for status, e.g. "Status"
Private Function GetActiveColorsFromTable(ByVal tableName As String, _
                                         ByVal colorColName As String, _
                                         ByVal statusColName As String) As Collection
    Dim result As New Collection
    
    Dim ws As Worksheet, lo As ListObject
    Dim found As Boolean
    found = False
    
    'Find the table anywhere in ThisWorkbook
    For Each ws In ThisWorkbook.Worksheets
        On Error Resume Next
        Set lo = ws.ListObjects(tableName)
        On Error GoTo 0
        
        If Not lo Is Nothing Then
            found = True
            Exit For
        End If
    Next ws
    
    If Not found Then
        'Return empty collection (or raise error if you prefer)
        Set GetActiveColorsFromTable = result
        Exit Function
    End If
    
    Dim colColor As ListColumn, colStatus As ListColumn
    Set colColor = lo.ListColumns(colorColName)
    Set colStatus = lo.ListColumns(statusColName)
    
    If lo.DataBodyRange Is Nothing Then
        Set GetActiveColorsFromTable = result
        Exit Function
    End If
    
    Dim i As Long
    For i = 1 To lo.DataBodyRange.Rows.Count
        Dim statusVal As String
        statusVal = Trim$(CStr(colStatus.DataBodyRange.Cells(i, 1).value))
        
        If UCase$(statusVal) = "ACTIVE" Then
            Dim clr As String
            clr = NormalizeColor(CStr(colColor.DataBodyRange.Cells(i, 1).value))
            If Len(clr) > 0 Then
                AddUniqueKeyed result, clr
            End If
        End If
    Next i
    
    Set GetActiveColorsFromTable = result
End Function

'Builds a 3 x N variant table:
'   tbl(1,i) = colorKey
'   tbl(2,i) = boxNum
'   tbl(3,i) = worksheetRow
Private Function BuildSectionIndex_FromRange(ByVal sectionRng As Range) As Variant
    If sectionRng Is Nothing Then
        BuildSectionIndex_FromRange = Empty
        Exit Function
    End If

    Dim descCol As Long, colorCol As Long
    GuessDescAndColorColumns sectionRng, descCol, colorCol

    Dim tmp() As Variant, cnt As Long
    ReDim tmp(1 To 3, 1 To 1)

    Dim lastColorKey As String
    lastColorKey = ""

    Dim r As Long
    For r = 1 To sectionRng.Rows.Count

        Dim desc As String
        desc = CStr(sectionRng.Cells(r, descCol).value)

        Dim bx As Long
        bx = ParseBoxNum(desc)

        If bx = 8 Then
            Dim U8 As String: U8 = UCase$(desc)
            If (InStr(1, U8, "NEW") > 0) And (InStr(1, U8, "ARMS") > 0 Or InStr(1, U8, "SRMS") > 0) Then
                GoTo NextRow
            End If
        End If
        If bx = 0 Then GoTo NextRow

        'Color with fill-down using detected color column
        Dim colorRaw As String, colorKey As String
        colorRaw = CStr(sectionRng.Cells(r, colorCol).value)
        colorKey = ""

        If IsLikelyColor(colorRaw) Then colorKey = NormalizeColor(colorRaw)
        If Len(colorKey) = 0 And Len(lastColorKey) > 0 Then colorKey = lastColorKey
        If Len(colorKey) = 0 Then GoTo NextRow

        lastColorKey = colorKey

        cnt = cnt + 1
        If cnt > UBound(tmp, 2) Then ReDim Preserve tmp(1 To 3, 1 To cnt)

        tmp(1, cnt) = colorKey
        tmp(2, cnt) = bx
        tmp(3, cnt) = r  'RELATIVE row inside sectionRng (1..Rows.Count)

NextRow:
    Next r

    If cnt = 0 Then
        BuildSectionIndex_FromRange = Empty
    Else
        BuildSectionIndex_FromRange = tmp
    End If
End Function

Private Function ParseBoxNum(ByVal s As String) As Long
    Dim U As String: U = UCase$(s)
    Dim p As Long: p = InStr(1, U, "BOX")
    If p = 0 Then Exit Function

    Dim i As Long, ch As String, numStr As String
    For i = p + 3 To Len(U)
        ch = Mid$(U, i, 1)

        'skip separators
        If ch = " " Or ch = "-" Or ch = ChrW(8211) Or ch = ChrW(8212) Or ch = ChrW(160) Then
            'skip
        ElseIf ch Like "#" Then
            numStr = numStr & ch
        ElseIf Len(numStr) > 0 Then
            Exit For
        End If
    Next i

    If Len(numStr) > 0 Then ParseBoxNum = CLng(numStr)
End Function

Private Function IsLikelyColor(ByVal v As Variant) As Boolean
    Dim s As String: s = Trim$(CStr(v))
    If Len(s) = 0 Then Exit Function
    If IsNumeric(s) Then Exit Function
    On Error Resume Next
    If IsDate(s) Then Exit Function
    On Error GoTo 0

    Dim i As Long, ch As String
    For i = 1 To Len(s)
        ch = Mid$(s, i, 1)
        If ch Like "[A-Za-z]" Then IsLikelyColor = True: Exit Function
    Next i
End Function

Private Function GetBoxCountFromTable(ByVal tableName As String) As Long
    Dim ws As Worksheet, lo As ListObject

    'Find the table anywhere in ThisWorkbook
    For Each ws In ThisWorkbook.Worksheets
        On Error Resume Next
        Set lo = ws.ListObjects(tableName)
        On Error GoTo 0

        If Not lo Is Nothing Then
            'DataBodyRange excludes header row
            If lo.DataBodyRange Is Nothing Then
                GetBoxCountFromTable = 0
            Else
                GetBoxCountFromTable = lo.DataBodyRange.Rows.Count
            End If
            Exit Function
        End If
    Next ws

    'Not found
    GetBoxCountFromTable = 0
End Function

'Builds a fast lookup:
'   key = "COLOR|BOX"  ->  worksheetRow
'First match wins (handles duplicates like discontinued items).
Private Function BuildRowMap(ByVal tbl As Variant) As Object
    Dim m As Object
    Set m = MapCreate()

    If IsEmpty(tbl) Then
        Set BuildRowMap = m
        Exit Function
    End If

    Dim i As Long, k As String
    For i = 1 To UBound(tbl, 2)
        k = CStr(tbl(1, i)) & "|" & CStr(tbl(2, i))
        MapAddFirst m, k, CLng(tbl(3, i))
    Next i

    Set BuildRowMap = m
End Function

'==================== CROSS-PLATFORM MAP ====================
' Uses Scripting.Dictionary if available; otherwise falls back to Collection of [key,value] pairs.
' Values are stored as Variant so you can store Long, Double, String, Date, etc.

Private Function MapCreate() As Object
    'Try Dictionary first (Windows)
    On Error Resume Next
    Dim d As Object
    Set d = CreateObject("Scripting.Dictionary")
    On Error GoTo 0

    If Not d Is Nothing Then
        d.CompareMode = 1 ' vbTextCompare
        Set MapCreate = d
    Else
        Dim c As Collection
        Set c = New Collection
        Set MapCreate = c
    End If
End Function

Private Function MapIsDictionary(ByVal m As Object) As Boolean
    Dim t As String
    t = TypeName(m)
    MapIsDictionary = (t = "Dictionary" Or t = "Scripting.Dictionary")
End Function

Private Function MapCount(ByVal m As Object) As Long
    MapCount = m.Count
End Function

Private Function MapExists(ByVal m As Object, ByVal key As String) As Boolean
    If MapIsDictionary(m) Then
        MapExists = m.Exists(key)
    Else
        Dim i As Long, pair As Variant
        For i = 1 To m.Count
            pair = m(i) ' pair = Array(key, value)
            If StrComp(CStr(pair(0)), key, vbTextCompare) = 0 Then
                MapExists = True
                Exit Function
            End If
        Next i
        MapExists = False
    End If
End Function

Private Sub MapAddFirst(ByVal m As Object, ByVal key As String, ByVal value As Variant)
    'Add only if missing (first match wins)
    If MapExists(m, key) Then Exit Sub

    If MapIsDictionary(m) Then
        m.Add key, value
    Else
        Dim pair As Variant
        pair = Array(key, value)
        m.Add pair
    End If
End Sub

Private Sub MapSet(ByVal m As Object, ByVal key As String, ByVal value As Variant)
    'Upsert (set even if key already exists)
    If MapIsDictionary(m) Then
        If m.Exists(key) Then
            m(key) = value
        Else
            m.Add key, value
        End If
    Else
        Dim i As Long, pair As Variant
        For i = 1 To m.Count
            pair = m(i)
            If StrComp(CStr(pair(0)), key, vbTextCompare) = 0 Then
                'Replace in-place by removing then inserting back at same position
                m.Remove i
                m.Add Array(key, value)
                Exit Sub
            End If
        Next i
        'Not found -> add new
        m.Add Array(key, value)
    End If
End Sub

Private Function MapGetVariant(ByVal m As Object, ByVal key As String, Optional ByVal defaultValue As Variant) As Variant
    If MapIsDictionary(m) Then
        If m.Exists(key) Then
            MapGetVariant = m(key)
        Else
            MapGetVariant = defaultValue
        End If
    Else
        Dim i As Long, pair As Variant
        For i = 1 To m.Count
            pair = m(i)
            If StrComp(CStr(pair(0)), key, vbTextCompare) = 0 Then
                MapGetVariant = pair(1)
                Exit Function
            End If
        Next i
        MapGetVariant = defaultValue
    End If
End Function

Private Function MapGetLong(ByVal m As Object, ByVal key As String, Optional ByVal defaultValue As Long = 0) As Long
    Dim v As Variant
    v = MapGetVariant(m, key, defaultValue)
    On Error Resume Next
    MapGetLong = CLng(v)
    If Err.Number <> 0 Then
        Err.Clear
        MapGetLong = defaultValue
    End If
    On Error GoTo 0
End Function

Private Function MapGetStr(ByVal m As Object, ByVal key As String, Optional ByVal defaultValue As String = vbNullString) As String
    Dim v As Variant
    v = MapGetVariant(m, key, defaultValue)
    If IsError(v) Or IsNull(v) Then
        MapGetStr = defaultValue
    Else
        MapGetStr = CStr(v)
    End If
End Function

Private Function MapGetDouble(ByVal m As Object, ByVal key As String, Optional ByVal defaultValue As Double = 0#) As Double
    Dim v As Variant
    v = MapGetVariant(m, key, defaultValue)
    On Error Resume Next
    MapGetDouble = CDbl(v)
    If Err.Number <> 0 Then
        Err.Clear
        MapGetDouble = defaultValue
    End If
    On Error GoTo 0
End Function

Private Function MapKeys(ByVal m As Object) As Variant
    'Returns a Variant array of keys. Safe for both Dictionary and Collection fallback.
    If MapIsDictionary(m) Then
        MapKeys = m.keys
    Else
        Dim keys() As Variant
        Dim i As Long, pair As Variant
        If m.Count = 0 Then
            MapKeys = Array()
            Exit Function
        End If
        ReDim keys(0 To m.Count - 1)
        For i = 1 To m.Count
            pair = m(i)
            keys(i - 1) = CStr(pair(0))
        Next i
        MapKeys = keys
    End If
End Function

Private Sub MapAddSumDouble(ByVal m As Object, ByVal key As String, ByVal addValue As Double)
    Dim cur As Double
    cur = MapGetDouble(m, key, 0#)
    MapSet m, key, (cur + addValue)
End Sub

'=== Fractional orders from qty and need ===
Private Function OrdersFromQty(ByVal qty As Double, ByVal need As Double) As Double
    If need <= 0 Then
        OrdersFromQty = 0
    ElseIf qty <= 0 Then
        OrdersFromQty = 0
    Else
        OrdersFromQty = qty / need
    End If
End Function

Private Function MinD(ByVal a As Double, ByVal b As Double) As Double
    If a < b Then
        MinD = a
    Else
        MinD = b
    End If
End Function

Private Function MinL(ByVal a As Long, ByVal b As Long) As Long
    If a < b Then
        MinL = a
    Else
        MinL = b
    End If
End Function

'=== Safe floor for "whole orders" ===
Private Function FloorWholeOrders(ByVal qty As Double, ByVal need As Double) As Long
    'Returns how many whole orders can be made from qty given need per order.
    'If need <= 0, returns 0 (prevents division errors).
    If need <= 0 Then
        FloorWholeOrders = 0
    ElseIf qty <= 0 Then
        FloorWholeOrders = 0
    Else
        FloorWholeOrders = CLng(Fix(qty / need)) 'Fix for positive values = floor
    End If
End Function


Private Function ToWhole(ByVal v As Variant) As Long
    'Fast round to whole; handles blanks/errors safely
    If IsError(v) Or Len(Trim$(CStr(v))) = 0 Then
        ToWhole = 0
    Else
        Dim d As Double
        d = CDbl(v)

        'Excel-like rounding to nearest integer
        If d >= 0 Then
            ToWhole = CLng(d + 0.5)
        Else
            ToWhole = -CLng(Abs(d) + 0.5)
        End If
    End If
End Function

'=== Read isOptional from the "Boxes" table into an array indexed by box number ===
Private Function GetIsOptionalByBox_Configured(ByVal maxBox As Long) As Boolean()
    Dim isOpt() As Boolean
    ReDim isOpt(1 To maxBox)

    Dim ws As Worksheet, lo As ListObject
    Dim idxBox As Long, idxIsOpt As Long

    'Find the table named "Boxes" anywhere in the workbook
    For Each ws In ThisWorkbook.Worksheets
        On Error Resume Next
        Set lo = ws.ListObjects(CFG_TABLE_BOXES_PREFERRED)   ' "Boxes"
        On Error GoTo 0
        If Not lo Is Nothing Then Exit For
    Next ws

    If lo Is Nothing Or lo.DataBodyRange Is Nothing Then
        GetIsOptionalByBox_Configured = isOpt
        Exit Function
    End If

    'We expect headers: "Boxes" and "isOptional"
    idxBox = GetListColumnIndexByAliases(lo, Array("Boxes", "Box"))
    idxIsOpt = GetListColumnIndexByAliases(lo, Array("isOptional", "Optional", "IsOptional"))

    If idxBox = 0 Or idxIsOpt = 0 Then
        GetIsOptionalByBox_Configured = isOpt
        Exit Function
    End If

    Dim r As Long, bx As Long, boxText As String, v As Variant
    For r = 1 To lo.DataBodyRange.Rows.Count
        boxText = CStr(lo.DataBodyRange.Cells(r, idxBox).value)   'ex: "Box 6"
        bx = ParseBoxNum(boxText)                                 'your ParseBoxNum reads "Box 6" -> 6

        If bx >= 1 And bx <= maxBox Then
            v = lo.DataBodyRange.Cells(r, idxIsOpt).value
            isOpt(bx) = (UCase$(Trim$(CStr(v))) = "TRUE" Or CStr(v) = "1")
        End If
    Next r

    GetIsOptionalByBox_Configured = isOpt
End Function

Private Function StripNeptunePrefix(ByVal wsName As String) As String
    'Turns "Neptune-Toronto" into "Toronto"
    wsName = Trim$(wsName)
    If Len(wsName) = 0 Then
        StripNeptunePrefix = ""
    ElseIf UCase$(Left$(wsName, 8)) = "NEPTUNE-" Then
        StripNeptunePrefix = Mid$(wsName, 9)
    Else
        StripNeptunePrefix = wsName
    End If
End Function

'Finds the allocMap key for a given USA city by scanning allocMap keys:
'  returns e.g. "USA|Neptune-Moreno" (or whatever the worksheet is called in WorksheetNames)
'If not found, returns "".
Private Function GetUSAAllocKeyForCity(ByVal allocMap As Object, ByVal city As String) As String
    Dim target As String
    target = UCase$(Trim$(city))

    Dim k As Variant
    Dim keyStr As String
    Dim parts() As String
    Dim wsName As String
    Dim wsCity As String

    For Each k In MapKeys(allocMap)
        keyStr = CStr(k)

        'Key format is "Country|Worksheet"
        If UCase$(Left$(keyStr, 4)) = "USA|" Then
            parts = Split(keyStr, "|")
            If UBound(parts) >= 1 Then
                wsName = parts(1) 'worksheet name portion
                wsCity = UCase$(StripNeptunePrefix(wsName))

                If wsCity = target Then
                    GetUSAAllocKeyForCity = "USA|" & wsName
                    Exit Function
                End If
            End If
        End If
    Next k

    GetUSAAllocKeyForCity = vbNullString
End Function

Private Function GetAllocKeyForCityCountry(ByVal allocMap As Object, ByVal country As String, ByVal city As String) As String
    Dim targetCountry As String, targetCity As String
    targetCountry = UCase$(Trim$(country))
    targetCity = UCase$(Trim$(city))

    Dim k As Variant, keyStr As String
    Dim parts() As String, wsName As String, wsCity As String

    For Each k In MapKeys(allocMap)
        keyStr = CStr(k)

        'Key format is "Country|Worksheet"
        parts = Split(keyStr, "|")
        If UBound(parts) >= 1 Then
            If UCase$(Trim$(parts(0))) = targetCountry Then
                wsName = parts(1)
                wsCity = UCase$(StripNeptunePrefix(wsName))

                If wsCity = targetCity Then
                    GetAllocKeyForCityCountry = targetCountry & "|" & wsName
                    Exit Function
                End If
            End If
        End If
    Next k

    GetAllocKeyForCityCountry = vbNullString
End Function


Private Function GetP1City(ByVal p1Map As Object, ByVal country As String, ByVal demandCity As String) As String
    Dim key As String
    Dim wsName As String, p1Ws As String

    wsName = "Neptune-" & demandCity
    key = country & "|" & wsName

    If MapExists(p1Map, key) Then
        p1Ws = MapGetStr(p1Map, key, vbNullString)
        GetP1City = StripNeptunePrefix(p1Ws)
    Else
        GetP1City = ""
    End If

End Function

Private Function GetP2City(ByVal p2Map As Object, ByVal country As String, ByVal demandCity As String) As String
    Dim key As String
    Dim wsName As String, p2Ws As String

    wsName = "Neptune-" & demandCity
    key = country & "|" & wsName

    If MapExists(p2Map, key) Then
        p2Ws = MapGetStr(p2Map, key, vbNullString)
        GetP2City = StripNeptunePrefix(p2Ws)
    Else
        GetP2City = ""
    End If

End Function

'==================== NEW DEBUG SHEET (City x Week x Color) =====================
'Creates a second debug sheet:
'Color | Week Start | Week End | <City>_AvailStock_Orders | <City>_Orders_Backlog | <City>_Orders_Sales ...

Private Sub Build_DebugSheet_CityWeekColor( _
    ByVal outArr As Variant, _
    ByVal outUsed As Long, _
    ByVal COL_ORD_BL_AVAIL As Long, _
    ByVal COL_ORD_BL_BACKLOG As Long, _
    ByVal COL_ORD_SALES_AVAIL As Long, _
    ByVal COL_ORD_SALES_DEMAND As Long, _
    ByVal allocMap As Object)

    Dim ws2 As Worksheet
    Dim sheetName As String
    sheetName = "Boxes_Shipped_DEBUG_CityWeek"

    '1) Create/clear sheet
    On Error Resume Next
    Set ws2 = ThisWorkbook.Worksheets(sheetName)
    On Error GoTo 0

    If ws2 Is Nothing Then
        Set ws2 = ThisWorkbook.Worksheets.Add(After:=ThisWorkbook.Worksheets(ThisWorkbook.Worksheets.Count))
        ws2.Name = sheetName
    End If
    ws2.Cells.Clear

    '2) Define cities in the exact order you want
    Dim cities As Variant
    cities = Array("Montreal", "Toronto", "Vancouver", "Moreno", "Dayton")

    '3) Build lookup map: key = City|Color|WeekStart -> Array(availOrders, backlogOrders, salesOrders)
    Dim m As Object
    Set m = MapCreate()

    Dim r As Long
    Dim city As String, colorKey As String, wkStartKey As String
    Dim k As String

    For r = 2 To outUsed
        city = Trim$(CStr(outArr(r, 1)))                 'Demand City
        colorKey = NormalizeColor(CStr(outArr(r, 3)))    'Color (normalized)
        wkStartKey = Format$(CDate(outArr(r, 4)), "yyyy-mm-dd")

        If Len(city) > 0 And Len(colorKey) > 0 Then
            k = city & "|" & colorKey & "|" & wkStartKey

            Dim payload As Variant
           payload = Array( _
                CDbl(outArr(r, COL_ORD_BL_AVAIL)), _
                CDbl(outArr(r, COL_ORD_BL_BACKLOG)), _
                CDbl(outArr(r, COL_ORD_SALES_DEMAND)), _
                CDbl(outArr(r, COL_ORD_SALES_AVAIL)) _
            )

            'First match wins
            MapAddFirst m, k, payload
        End If
    Next r

    '4) Build unique list of (Color|WeekStart) rows and remember WeekEnd
    Dim rowKeys As Object
    Set rowKeys = MapCreate()

    Dim wkStartDate As Date, wkEndDate As Date
    Dim rowKey As String

    For r = 2 To outUsed
        colorKey = NormalizeColor(CStr(outArr(r, 3)))
        wkStartDate = CDate(outArr(r, 4))
        wkEndDate = CDate(outArr(r, 5))

        rowKey = colorKey & "|" & Format$(wkStartDate, "yyyy-mm-dd")

        'Store WeekEnd as the value (first match wins)
        MapAddFirst rowKeys, rowKey, wkEndDate
    Next r

    '5) Prepare output array for the new sheet
    Dim nRows As Long, nCols As Long
    nRows = MapCount(rowKeys) + 1 ' + header row
    
    'Order required:
    '3 base cols +
    '6 CAN city cols (avail/backlog for Montreal/Toronto/Vancouver) +
    '13 CAN flow cols (scenario + 9 flows + 3 totals) +
    '4 USA city cols (avail/backlog for Moreno/Dayton) +
    '7 USA flow cols (scenario + 4 flows + 2 totals) +
    '5 sales cols (one per city)
    nCols = 3 + 6 + 13 + 4 + 7 + 10

    Dim out2() As Variant
    ReDim out2(1 To nRows, 1 To nCols)

   'Headers
    out2(1, 1) = "Color"
    out2(1, 2) = "Week Start"
    out2(1, 3) = "Week End"
    
    '--- Column pointers (1-based) for REQUIRED ORDER ---
    Dim colPtr As Long
    colPtr = 4
    
    'CAN city (avail/backlog only)
    Dim COL_Mon_Av As Long, COL_Mon_BL As Long
    Dim COL_Tor_Av As Long, COL_Tor_BL As Long
    Dim COL_Van_Av As Long, COL_Van_BL As Long
    
    COL_Mon_Av = colPtr: out2(1, colPtr) = "Montreal_AvailStock_Orders": colPtr = colPtr + 1
    COL_Mon_BL = colPtr: out2(1, colPtr) = "Montreal_Orders_Backlog":   colPtr = colPtr + 1
    
    COL_Tor_Av = colPtr: out2(1, colPtr) = "Toronto_AvailStock_Orders":  colPtr = colPtr + 1
    COL_Tor_BL = colPtr: out2(1, colPtr) = "Toronto_Orders_Backlog":     colPtr = colPtr + 1
    
    COL_Van_Av = colPtr: out2(1, colPtr) = "Vancouver_AvailStock_Orders": colPtr = colPtr + 1
    COL_Van_BL = colPtr: out2(1, colPtr) = "Vancouver_Orders_Backlog":    colPtr = colPtr + 1
    
    'CAN allocation + flows + totals
    Dim canBaseCol As Long
    canBaseCol = colPtr
    
    out2(1, canBaseCol + 0) = "CAN_Allocation_Scenario"
    
    out2(1, canBaseCol + 1) = "Montreal_Backlog_Shipped_FromMontreal"
    out2(1, canBaseCol + 2) = "Montreal_Backlog_Shipped_FromToronto"
    out2(1, canBaseCol + 3) = "Montreal_Backlog_Shipped_FromVancouver"
    
    out2(1, canBaseCol + 4) = "Toronto_Backlog_Shipped_FromMontreal"
    out2(1, canBaseCol + 5) = "Toronto_Backlog_Shipped_FromToronto"
    out2(1, canBaseCol + 6) = "Toronto_Backlog_Shipped_FromVancouver"
    
    out2(1, canBaseCol + 7) = "Vancouver_Backlog_Shipped_FromMontreal"
    out2(1, canBaseCol + 8) = "Vancouver_Backlog_Shipped_FromToronto"
    out2(1, canBaseCol + 9) = "Vancouver_Backlog_Shipped_FromVancouver"
    
    out2(1, canBaseCol + 10) = "Total_Backlog_FromMontreal"
    out2(1, canBaseCol + 11) = "Total_Backlog_FromToronto"
    out2(1, canBaseCol + 12) = "Total_Backlog_FromVancouver"
    
    colPtr = canBaseCol + 13
    
    'USA city (avail/backlog only)
    Dim COL_Mor_Av As Long, COL_Mor_BL As Long
    Dim COL_Day_Av As Long, COL_Day_BL As Long
    
    COL_Mor_Av = colPtr: out2(1, colPtr) = "Moreno_AvailStock_Orders": colPtr = colPtr + 1
    COL_Mor_BL = colPtr: out2(1, colPtr) = "Moreno_Backlog_Orders":   colPtr = colPtr + 1
    
    COL_Day_Av = colPtr: out2(1, colPtr) = "Dayton_AvailStock_Orders": colPtr = colPtr + 1
    COL_Day_BL = colPtr: out2(1, colPtr) = "Dayton_Backlog_Orders":    colPtr = colPtr + 1
    
    'USA allocation + flows + totals
    Dim usaBaseCol As Long
    usaBaseCol = colPtr
    
    out2(1, usaBaseCol + 0) = "USA_Allocation_Scenario"
    out2(1, usaBaseCol + 1) = "Moreno_Backlog_Shipped_FromMoreno"
    out2(1, usaBaseCol + 2) = "Moreno_Backlog_Shipped_FromDayton"
    out2(1, usaBaseCol + 3) = "Dayton_Backlog_Shipped_FromMoreno"
    out2(1, usaBaseCol + 4) = "Dayton_Backlog_Shipped_FromDayton"
    out2(1, usaBaseCol + 5) = "Total_Backlog_FromMoreno"
    out2(1, usaBaseCol + 6) = "Total_Backlog_FromDayton"
    
    colPtr = usaBaseCol + 7
    
    'FINAL 10 columns (exact order requested):
    ' Montreal_AvailStockPostBacklog_Orders, Montreal_Sales_Orders, Toronto_AvailStockPostBacklog_Orders, Toronto_Sales_Orders, ...
    
    Dim COL_Mon_PostBL As Long, COL_Tor_PostBL As Long, COL_Van_PostBL As Long, COL_Mor_PostBL As Long, COL_Day_PostBL As Long
    Dim COL_Mon_Sales As Long, COL_Tor_Sales As Long, COL_Van_Sales As Long, COL_Mor_Sales As Long, COL_Day_Sales As Long
    
    COL_Mon_PostBL = colPtr: out2(1, colPtr) = "Montreal_AvailStockPostBacklog_Orders": colPtr = colPtr + 1
    COL_Mon_Sales  = colPtr: out2(1, colPtr) = "Montreal_Sales_Orders":                 colPtr = colPtr + 1
    
    COL_Tor_PostBL = colPtr: out2(1, colPtr) = "Toronto_AvailStockPostBacklog_Orders":  colPtr = colPtr + 1
    COL_Tor_Sales  = colPtr: out2(1, colPtr) = "Toronto_Sales_Orders":                  colPtr = colPtr + 1
    
    COL_Van_PostBL = colPtr: out2(1, colPtr) = "Vancouver_AvailStockPostBacklog_Orders": colPtr = colPtr + 1
    COL_Van_Sales  = colPtr: out2(1, colPtr) = "Vancouver_Sales_Orders":                 colPtr = colPtr + 1
    
    COL_Mor_PostBL = colPtr: out2(1, colPtr) = "Moreno_AvailStockPostBacklog_Orders":    colPtr = colPtr + 1
    COL_Mor_Sales  = colPtr: out2(1, colPtr) = "Moreno_Sales_Orders":                    colPtr = colPtr + 1
    
    COL_Day_PostBL = colPtr: out2(1, colPtr) = "Dayton_AvailStockPostBacklog_Orders":    colPtr = colPtr + 1
    COL_Day_Sales  = colPtr: out2(1, colPtr) = "Dayton_Sales_Orders":                    colPtr = colPtr + 1

    '6) Write rows
    Dim keys As Variant
    keys = MapKeys(rowKeys)

    Dim i As Long
    Dim parts() As String
    Dim wkStartStr As String
    Dim wkEndVal As Date

    Dim payloadOut As Variant
    Dim kk As String

    i = 1
    Dim keyItem As Variant
    For Each keyItem In keys
        i = i + 1

        parts = Split(CStr(keyItem), "|")
        colorKey = parts(0)
        wkStartStr = parts(1)
        wkEndVal = CDate(MapGetVariant(rowKeys, CStr(keyItem), 0))

        out2(i, 1) = colorKey
        out2(i, 2) = CDate(wkStartStr)
        out2(i, 3) = wkEndVal

    'Fill required columns explicitly (no more baseCol + (c*3) layout)

    Dim p As Variant
    
    '--- Montreal ---
    kk = "Montreal" & "|" & colorKey & "|" & wkStartStr
    If MapExists(m, kk) Then
        p = MapGetVariant(m, kk, Empty)
        out2(i, COL_Mon_Av)     = CDbl(p(0))
        out2(i, COL_Mon_BL)     = CDbl(p(1))
        out2(i, COL_Mon_Sales)  = CDbl(p(2))
        out2(i, COL_Mon_PostBL) = CDbl(p(3))
    Else
        out2(i, COL_Mon_Av) = 0
        out2(i, COL_Mon_BL) = 0
        out2(i, COL_Mon_Sales) = 0
        out2(i, COL_Mon_PostBL) = 0
    End If
    
    '--- Toronto ---
    kk = "Toronto" & "|" & colorKey & "|" & wkStartStr
    If MapExists(m, kk) Then
        p = MapGetVariant(m, kk, Empty)
        out2(i, COL_Tor_Av) = CDbl(p(0))
        out2(i, COL_Tor_BL) = CDbl(p(1))
        out2(i, COL_Tor_Sales) = CDbl(p(2))
        out2(i, COL_Tor_PostBL) = CDbl(p(3))
    Else
        out2(i, COL_Tor_Av) = 0
        out2(i, COL_Tor_BL) = 0
        out2(i, COL_Tor_Sales) = 0
        out2(i, COL_Tor_PostBL) = 0
    End If
    
    '--- Vancouver ---
    kk = "Vancouver" & "|" & colorKey & "|" & wkStartStr
    If MapExists(m, kk) Then
        p = MapGetVariant(m, kk, Empty)
        out2(i, COL_Van_Av) = CDbl(p(0))
        out2(i, COL_Van_BL) = CDbl(p(1))
        out2(i, COL_Van_Sales) = CDbl(p(2))
        out2(i, COL_Van_PostBL) = CDbl(p(3))
    Else
        out2(i, COL_Van_Av) = 0
        out2(i, COL_Van_BL) = 0
        out2(i, COL_Van_Sales) = 0
        out2(i, COL_Van_PostBL) = 0
    End If
    
    '--- Moreno ---
    kk = "Moreno" & "|" & colorKey & "|" & wkStartStr
    If MapExists(m, kk) Then
        p = MapGetVariant(m, kk, Empty)
        out2(i, COL_Mor_Av) = CDbl(p(0))
        out2(i, COL_Mor_BL) = CDbl(p(1))
        out2(i, COL_Mor_Sales) = CDbl(p(2))
        out2(i, COL_Mor_PostBL) = CDbl(p(3))
    Else
        out2(i, COL_Mor_Av) = 0
        out2(i, COL_Mor_BL) = 0
        out2(i, COL_Mor_Sales) = 0
        out2(i, COL_Mor_PostBL) = 0
    End If
    
    '--- Dayton ---
    kk = "Dayton" & "|" & colorKey & "|" & wkStartStr
    If MapExists(m, kk) Then
        p = MapGetVariant(m, kk, Empty)
        out2(i, COL_Day_Av) = CDbl(p(0))
        out2(i, COL_Day_BL) = CDbl(p(1))
        out2(i, COL_Day_Sales) = CDbl(p(2))
        out2(i, COL_Day_PostBL) = CDbl(p(3))
    Else
        out2(i, COL_Day_Av) = 0
        out2(i, COL_Day_BL) = 0
        out2(i, COL_Day_Sales) = 0
        out2(i, COL_Day_PostBL) = 0
    End If
      
    '=== USA allocation + flows (Moreno/Dayton backlog shipping) ===
    Dim A_M As Double, B_M As Double, A_D As Double, B_D As Double
    A_M = CDbl(out2(i, COL_Mor_Av)) 'Moreno_AvailStock_Orders
    B_M = CDbl(out2(i, COL_Mor_BL)) 'Moreno_Backlog_Orders
    
    A_D = CDbl(out2(i, COL_Day_Av)) 'Dayton_AvailStock_Orders
    B_D = CDbl(out2(i, COL_Day_BL)) 'Dayton_Backlog_Orders
    
    Dim scen As String
    Dim M_from_M As Double, M_from_D As Double, D_from_M As Double, D_from_D As Double
    
    '--- Get USA allocation shares dynamically from allocMap (built from WorksheetNames) ---
    Dim shMor As Double, shDay As Double
    Dim kMor As String, kDay As String
    
    kMor = GetUSAAllocKeyForCity(allocMap, "Moreno")
    kDay = GetUSAAllocKeyForCity(allocMap, "Dayton")

    If Len(kMor) = 0 Or Len(kDay) = 0 Then
        scen = "WARN_USA_AllocKey_Missing_In_WorksheetNames"
    End If
    
    shMor = MapGetDouble(allocMap, kMor, 0.35)
    shDay = MapGetDouble(allocMap, kDay, 0.65)
    
    'Optional safety: if they don't sum to ~1, normalize (prevents bad inputs)
    Dim shSum As Double
    shSum = shMor + shDay
    If shSum > 0.0000001 Then
        shMor = shMor / shSum
        shDay = shDay / shSum
    End If
    
    Call Compute_USA_Backlog_Flows(A_M, B_M, A_D, B_D, shMor, shDay, scen, M_from_M, M_from_D, D_from_M, D_from_D)
    
    out2(i, usaBaseCol + 0) = scen
    out2(i, usaBaseCol + 1) = M_from_M
    out2(i, usaBaseCol + 2) = M_from_D
    out2(i, usaBaseCol + 3) = D_from_M
    out2(i, usaBaseCol + 4) = D_from_D
    out2(i, usaBaseCol + 5) = M_from_M + D_from_M   ' Total shipped FROM Moreno
    out2(i, usaBaseCol + 6) = M_from_D + D_from_D   ' Total shipped FROM Dayton

    '=== CAN allocation + flows (Montreal/Toronto/Vancouver backlog shipping) ===
    Dim A_Mon As Double, B_Mon As Double
    Dim A_Tor As Double, B_Tor As Double
    Dim A_Van As Double, B_Van As Double
    
    A_Mon = CDbl(out2(i, COL_Mon_Av)) ' Montreal_AvailStock_Orders
    B_Mon = CDbl(out2(i, COL_Mon_BL)) ' Montreal_Orders_Backlog
    
    A_Tor = CDbl(out2(i, COL_Tor_Av)) ' Toronto_AvailStock_Orders
    B_Tor = CDbl(out2(i, COL_Tor_BL)) ' Toronto_Orders_Backlog
    
    A_Van = CDbl(out2(i, COL_Van_Av)) ' Vancouver_AvailStock_Orders
    B_Van = CDbl(out2(i, COL_Van_BL)) ' Vancouver_Orders_Backlog
    
    Dim scenCAN As String
    Dim Mon_from_Mon As Double, Mon_from_Tor As Double, Mon_from_Van As Double
    Dim Tor_from_Mon As Double, Tor_from_Tor As Double, Tor_from_Van As Double
    Dim Van_from_Mon As Double, Van_from_Tor As Double, Van_from_Van As Double

    '--- Get CAN allocation shares dynamically from allocMap (WorksheetNames) ---
    'Fallback defaults: 25/50/25 if keys not found
    Dim shMon As Double, shTor As Double, shVan As Double
    Dim kMon As String, kTor As String, kVan As String

    kMon = GetAllocKeyForCityCountry(allocMap, "CAN", "Montreal")
    kTor = GetAllocKeyForCityCountry(allocMap, "CAN", "Toronto")
    kVan = GetAllocKeyForCityCountry(allocMap, "CAN", "Vancouver")

    shMon = MapGetDouble(allocMap, kMon, 0.25)
    shTor = MapGetDouble(allocMap, kTor, 0.5)
    shVan = MapGetDouble(allocMap, kVan, 0.25)

    'Normalize if they don't sum to ~1
    Dim shSumCAN As Double
    shSumCAN = shMon + shTor + shVan
    If shSumCAN > 0.0000001 Then
        shMon = shMon / shSumCAN
        shTor = shTor / shSumCAN
        shVan = shVan / shSumCAN
    End If

    Call Compute_CAN_Backlog_Flows( _
        A_Mon, B_Mon, A_Tor, B_Tor, A_Van, B_Van, _
        shMon, shTor, shVan, _
        scenCAN, _
        Mon_from_Mon, Mon_from_Tor, Mon_from_Van, _
        Tor_from_Mon, Tor_from_Tor, Tor_from_Van, _
        Van_from_Mon, Van_from_Tor, Van_from_Van)

    out2(i, canBaseCol + 0) = scenCAN

    out2(i, canBaseCol + 1) = Mon_from_Mon
    out2(i, canBaseCol + 2) = Mon_from_Tor
    out2(i, canBaseCol + 3) = Mon_from_Van

    out2(i, canBaseCol + 4) = Tor_from_Mon
    out2(i, canBaseCol + 5) = Tor_from_Tor
    out2(i, canBaseCol + 6) = Tor_from_Van

    out2(i, canBaseCol + 7) = Van_from_Mon
    out2(i, canBaseCol + 8) = Van_from_Tor
    out2(i, canBaseCol + 9) = Van_from_Van

    out2(i, canBaseCol + 10) = Mon_from_Mon + Tor_from_Mon + Van_from_Mon  ' total shipped FROM Montreal
    out2(i, canBaseCol + 11) = Mon_from_Tor + Tor_from_Tor + Van_from_Tor  ' total shipped FROM Toronto
    out2(i, canBaseCol + 12) = Mon_from_Van + Tor_from_Van + Van_from_Van  ' total shipped FROM Vancouver

    Next keyItem

    '7) Dump to sheet
    ws2.Range("A1").Resize(nRows, nCols).Value = out2

    '8) Formatting
    ws2.Columns(2).NumberFormat = "yyyy-mm-dd"
    ws2.Columns(3).NumberFormat = "yyyy-mm-dd"
    
    'Format city numeric blocks
    ws2.Range(ws2.Cells(2, 4), ws2.Cells(nRows, usaBaseCol - 1)).NumberFormat = "0.00"
    
    'Scenario columns = text
    ws2.Columns(usaBaseCol).NumberFormat = "@"
    ws2.Columns(canBaseCol).NumberFormat = "@"

    'USA flow columns = numeric
    ws2.Range(ws2.Cells(2, usaBaseCol + 1), ws2.Cells(nRows, usaBaseCol + 6)).NumberFormat = "0.00"

    'CAN flow columns = numeric (12 numeric columns after scenario)
    ws2.Range(ws2.Cells(2, canBaseCol + 1), ws2.Cells(nRows, canBaseCol + 12)).NumberFormat = "0.00"


End Sub

'==================== NEW: Override OrdersShipped_Backlog from CityWeek totals =====================
'After Boxes_Shipped_DEBUG_CityWeek is created, we read:
'  Total_Backlog_FromMontreal/Toronto/Vancouver/Moreno/Dayton
'and override OrdersShipped_Backlog in outArr for matching (DemandCity, Color, WeekStart).
'Then we recompute:
'  BacklogShipped Bn
'  AvailStock_PostBacklog Bn
'  Sales orders + SalesShipped Bn
'so everything behaves the same as current logic, just with the new OrdersShipped_Backlog.

Private Sub Apply_BacklogOverride_FromCityWeek( _
    ByRef outArr As Variant, _
    ByVal outUsed As Long, _
    ByVal COL_ORD_BL_SHIP As Long, _
    ByVal COL_AVAIL As Long, _
    ByVal COL_NEED As Long, _
    ByVal COL_BL_SHIP As Long, _
    ByVal COL_AVAIL_POSTBL As Long, _
    ByVal COL_SALES As Long, _
    ByVal COL_ORD_SALES_AVAIL As Long, _
    ByVal COL_ORD_SALES_DEMAND As Long, _
    ByVal COL_ORD_SALES_SHIP As Long, _
    ByVal COL_SALES_SHIP As Long, _
    ByVal MAX_BOX As Long, _
    ByRef isOptional() As Boolean)

    Dim wsCW As Worksheet
    On Error Resume Next
    Set wsCW = ThisWorkbook.Worksheets("Boxes_Shipped_DEBUG_CityWeek")
    On Error GoTo 0
    If wsCW Is Nothing Then Exit Sub

    'Read CityWeek sheet into an array
    Dim lastRow As Long, lastCol As Long
    lastRow = wsCW.Cells(wsCW.Rows.Count, 1).End(xlUp).Row
    lastCol = wsCW.Cells(1, wsCW.Columns.Count).End(xlToLeft).Column
    If lastRow < 2 Or lastCol < 3 Then Exit Sub

    Dim cw As Variant
    cw = wsCW.Range(wsCW.Cells(1, 1), wsCW.Cells(lastRow, lastCol)).Value

    'Locate needed columns by header name
    Dim cColor As Long, cWkStart As Long
    Dim cTotMon As Long, cTotTor As Long, cTotVan As Long
    Dim cTotMor As Long, cTotDay As Long

    cColor = FindHeaderCol_1Row(cw, "Color")
    cWkStart = FindHeaderCol_1Row(cw, "Week Start")

    cTotMon = FindHeaderCol_1Row(cw, "Total_Backlog_FromMontreal")
    cTotTor = FindHeaderCol_1Row(cw, "Total_Backlog_FromToronto")
    cTotVan = FindHeaderCol_1Row(cw, "Total_Backlog_FromVancouver")
    cTotMor = FindHeaderCol_1Row(cw, "Total_Backlog_FromMoreno")
    cTotDay = FindHeaderCol_1Row(cw, "Total_Backlog_FromDayton")

    'Minimum required: Color + Week Start + at least one Total_Backlog_From*
    If cColor = 0 Or cWkStart = 0 Then Exit Sub
    If cTotMon = 0 And cTotTor = 0 And cTotVan = 0 And cTotMor = 0 And cTotDay = 0 Then Exit Sub

    'Build map: key = COLOR|yyyy-mm-dd -> Array(mon, tor, van, mor, day)
    Dim mTotals As Object
    Set mTotals = MapCreate()

    Dim r As Long
    Dim colorKey As String, wkKey As String, k As String
    Dim arr5 As Variant

    For r = 2 To UBound(cw, 1)
        colorKey = NormalizeColor(CStr(cw(r, cColor)))
        If Len(colorKey) = 0 Then GoTo NextCWRow

        If IsDate(cw(r, cWkStart)) Then
            wkKey = Format$(CDate(cw(r, cWkStart)), "yyyy-mm-dd")
        Else
            GoTo NextCWRow
        End If

        arr5 = Array( _
            NzD(cw(r, cTotMon)), _
            NzD(cw(r, cTotTor)), _
            NzD(cw(r, cTotVan)), _
            NzD(cw(r, cTotMor)), _
            NzD(cw(r, cTotDay)) _
        )

        k = colorKey & "|" & wkKey
        MapSet mTotals, k, arr5

NextCWRow:
    Next r

    'Apply override row-by-row in outArr, and recompute dependent columns
    Dim rr As Long, b As Long
    Dim demandCity As String
    Dim newShipOrders As Double
    Dim payload As Variant
    Dim ordersFromAvail2 As Double, ordersFromSales As Double, ordersShipped_Sales As Double
    Dim availVal As Double, needVal As Double, salesVal As Double
    Dim desiredBL As Double, shippedBL As Double, availPost As Double
    Dim desiredS As Double, shippedS As Double

    For rr = 2 To outUsed

        demandCity = UCase$(Trim$(CStr(outArr(rr, 1))))
        colorKey = NormalizeColor(CStr(outArr(rr, 3)))
        wkKey = Format$(CDate(outArr(rr, 4)), "yyyy-mm-dd")

        k = colorKey & "|" & wkKey

        If MapExists(mTotals, k) Then
            payload = MapGetVariant(mTotals, k, Empty)

            Select Case demandCity
                Case "MONTREAL":  newShipOrders = CDbl(payload(0))
                Case "TORONTO":   newShipOrders = CDbl(payload(1))
                Case "VANCOUVER": newShipOrders = CDbl(payload(2))
                Case "MORENO":    newShipOrders = CDbl(payload(3))
                Case "DAYTON":    newShipOrders = CDbl(payload(4))
                Case Else
                    'Unknown city -> don't override
                    GoTo NextOutRow
            End Select

            'Override OrdersShipped_Backlog
            outArr(rr, COL_ORD_BL_SHIP) = WorksheetFunction.Round(newShipOrders, 2)

            'Recompute BacklogShipped + AvailStock_PostBacklog using the same logic you already use
            For b = 1 To MAX_BOX

                needVal = CDbl(outArr(rr, COL_NEED + (b - 1)))
                If needVal <= 0 Then needVal = 1

                desiredBL = newShipOrders * needVal

                If isOptional(b) Then
                    availVal = CDbl(outArr(rr, COL_AVAIL + (b - 1)))
                    shippedBL = MinD(availVal, desiredBL)
                Else
                    shippedBL = desiredBL
                End If

                outArr(rr, COL_BL_SHIP + (b - 1)) = shippedBL

                availPost = CDbl(outArr(rr, COL_AVAIL + (b - 1))) - shippedBL
                If availPost < 0 Then availPost = 0
                outArr(rr, COL_AVAIL_POSTBL + (b - 1)) = availPost

            Next b

            'Recompute Sales-after-backlog (because it depends on AvailStock_PostBacklog)
            ordersFromAvail2 = 1E+30
            ordersFromSales = 1E+30

            For b = 1 To MAX_BOX
                If Not isOptional(b) Then
                    salesVal = CDbl(outArr(rr, COL_SALES + (b - 1)))
                    availVal = CDbl(outArr(rr, COL_AVAIL_POSTBL + (b - 1)))
                    needVal = CDbl(outArr(rr, COL_NEED + (b - 1)))
                    If needVal <= 0 Then needVal = 1

                    ordersFromAvail2 = MinD(ordersFromAvail2, OrdersFromQty(availVal, needVal))
                    ordersFromSales = MinD(ordersFromSales, OrdersFromQty(salesVal, needVal))
                End If
            Next b

            If ordersFromAvail2 = 1E+30 Then ordersFromAvail2 = 0
            If ordersFromSales = 1E+30 Then ordersFromSales = 0

            ordersShipped_Sales = MinD(ordersFromAvail2, ordersFromSales)

            outArr(rr, COL_ORD_SALES_AVAIL) = WorksheetFunction.Round(ordersFromAvail2, 2)
            outArr(rr, COL_ORD_SALES_DEMAND) = WorksheetFunction.Round(ordersFromSales, 2)
            outArr(rr, COL_ORD_SALES_SHIP) = WorksheetFunction.Round(ordersShipped_Sales, 2)

            For b = 1 To MAX_BOX
                needVal = CDbl(outArr(rr, COL_NEED + (b - 1)))
                If needVal <= 0 Then needVal = 1

                desiredS = ordersShipped_Sales * needVal

                If isOptional(b) Then
                    availVal = CDbl(outArr(rr, COL_AVAIL_POSTBL + (b - 1)))
                    shippedS = MinD(availVal, desiredS)
                Else
                    shippedS = desiredS
                End If

                outArr(rr, COL_SALES_SHIP + (b - 1)) = shippedS
            Next b

        End If

NextOutRow:
    Next rr

End Sub

'Finds a header in row 1 of a 2D Variant array (1-based),
'returns the column index or 0 if not found.
Private Function FindHeaderCol_1Row(ByVal arr As Variant, ByVal headerName As String) As Long
    Dim c As Long
    For c = 1 To UBound(arr, 2)
        If StrComp(Trim$(CStr(arr(1, c))), Trim$(headerName), vbTextCompare) = 0 Then
            FindHeaderCol_1Row = c
            Exit Function
        End If
    Next c
    FindHeaderCol_1Row = 0
End Function

'Numeric-safe conversion (blank/errors -> 0)
Private Function NzD(ByVal v As Variant) As Double
    If IsError(v) Or IsNull(v) Then
        NzD = 0#
    ElseIf Len(Trim$(CStr(v))) = 0 Then
        NzD = 0#
    ElseIf IsNumeric(v) Then
        NzD = CDbl(v)
    Else
        NzD = 0#
    End If
End Function

Private Sub Compute_USA_Backlog_Flows( _
    ByVal A_M As Double, ByVal B_M As Double, _
    ByVal A_D As Double, ByVal B_D As Double, _
    ByVal SH_M As Double, ByVal SH_D As Double, _
    ByRef scenario As String, _
    ByRef M_from_M As Double, ByRef M_from_D As Double, _
    ByRef D_from_M As Double, ByRef D_from_D As Double)

    Const EPS As Double = 0.0000001


    Dim A_T As Double, B_T As Double
    A_T = A_M + A_D
    B_T = B_M + B_D

    'defaults
    scenario = ""
    M_from_M = 0: M_from_D = 0
    D_from_M = 0: D_from_D = 0

    Dim M_has As Boolean, D_has As Boolean
    M_has = (A_M > EPS)
    D_has = (A_D > EPS)

    'Scenario 5: both OOS
    If (Not M_has) And (Not D_has) Then
        scenario = "5_Both_OOS"
        Exit Sub
    End If

    'Scenario 1: both can cover own backlog with own stock
    If (A_M >= B_M) And (A_D >= B_D) Then
        scenario = "1_Both_Cover_Own"
        M_from_M = B_M
        D_from_D = B_D
        Exit Sub
    End If

    'From here, we only apply scenarios 2/3/4 when EXACTLY ONE city has stock.
    'If both have stock but not enough to cover their own backlog, apply pooled-share allocation
    'ONLY for this previously-UNDEFINED case.
    If M_has And D_has Then

        '==================== NEW: Pooled stock allocation (Undefined fix) ====================
        '1) Allocate TOTAL stock by share
        '2) Cap by each city's backlog
        '3) Spill unused allocation to the other city (if unmet)
        '4) Route shipments local-first (use local stock before cross-ship)

        Dim allocM As Double, allocD As Double
        Dim shipM As Double, shipD As Double
        Dim leftoverM As Double, leftoverD As Double

        'Allocation by share from total stock
        allocM = SH_M * A_T
        allocD = SH_D * A_T

        'Cap by backlog
        shipM = MinD(B_M, allocM)
        shipD = MinD(B_D, allocD)

        'Leftover from share allocations
        leftoverM = allocM - shipM
        leftoverD = allocD - shipD

        'Spill Moreno unused share -> Dayton unmet
        If leftoverM > EPS Then
            If shipD + EPS < B_D Then
                shipD = MinD(B_D, shipD + leftoverM)
            End If
        End If

        'Spill Dayton unused share -> Moreno unmet
        If leftoverD > EPS Then
            If shipM + EPS < B_M Then
                shipM = MinD(B_M, shipM + leftoverD)
            End If
        End If

        '==================== ROUTING: local-first ====================
        'First satisfy each destination using its local stock, then cross-ship if needed.

        Dim remA_M As Double, remA_D As Double
        Dim remShipM As Double, remShipD As Double

        'Local shipments
        M_from_M = MinD(A_M, shipM)
        D_from_D = MinD(A_D, shipD)

        remA_M = A_M - M_from_M
        remA_D = A_D - D_from_D

        remShipM = shipM - M_from_M
        remShipD = shipD - D_from_D

        'Cross shipments (only if destination still needs)
        If remShipM > EPS Then
            M_from_D = MinD(remA_D, remShipM)
        End If

        If remShipD > EPS Then
            D_from_M = MinD(remA_M, remShipD)
        End If

        scenario = "8_Both_Have_Stock_But_Not_Covering_PooledShare_LocalFirst"

        Exit Sub
    End If


    'Exactly one has stock:
    Dim source As String
    If M_has Then source = "Moreno" Else source = "Dayton"

    'Scenario 2: one OOS, other can cover ALL backlog
    If A_T >= B_T Then
        If source = "Moreno" Then
            scenario = "2_Dayton_OOS_Moreno_Covers_All"
            M_from_M = B_M
            D_from_M = B_D
        Else
            scenario = "2_Moreno_OOS_Dayton_Covers_All"
            M_from_D = B_M
            D_from_D = B_D
        End If
        Exit Sub
    End If

    'Scenario 3/4: one OOS, other only partially covers total backlog -> 35/65 allocation + spill from Moreno share
    Dim allocM As Double, allocD As Double
    Dim shipM As Double, shipD As Double
    
    'Start with proportional allocations
    allocM = SH_M * A_T
    allocD = SH_D * A_T
    
    'Cap each city at its backlog first
    shipM = MinD(B_M, allocM)
    shipD = MinD(B_D, allocD)
    
    'Compute leftover from each share (unused allocated stock)
    Dim leftoverM As Double, leftoverD As Double
    leftoverM = allocM - shipM  'unused Moreno-share
    leftoverD = allocD - shipD  'unused Dayton-share
    
    'Spill leftovers to the OTHER city if that other city still has unmet backlog
    '1) Moreno leftover -> Dayton
    If leftoverM > EPS Then
        If shipD + EPS < B_D Then
            shipD = MinD(B_D, shipD + leftoverM)
            leftoverM = allocM - shipM 'not needed further, but keep clean
        End If
    End If
    
    '2) Dayton leftover -> Moreno  (NEW scenario)
    If leftoverD > EPS Then
        If shipM + EPS < B_M Then
            shipM = MinD(B_M, shipM + leftoverD)
            leftoverD = allocD - shipD
        End If
    End If
    
    'Now choose scenario label for sanity checking
    If (allocM <= B_M + EPS) And (allocD <= B_D + EPS) Then
        scenario = "3_One_OOS_Partial_Strict_35_65"
    ElseIf (allocM > B_M + EPS) And (allocD <= B_D + EPS) Then
        scenario = "4_One_OOS_Partial_Spill_MorenoShare_To_Dayton"
    ElseIf (allocD > B_D + EPS) And (allocM <= B_M + EPS) Then
        scenario = "6_One_OOS_Partial_Spill_DaytonShare_To_Moreno"
    Else
        'Both shares exceed their respective backlog (rare but possible if B_M/B_D are tiny)
        'Spills may happen both ways but shipments are capped by backlog anyway.
        scenario = "7_One_OOS_Partial_BothShares_Exceed_Backlog"
    End If

    'Write flows depending on which city is the SOURCE of stock
    If source = "Moreno" Then
        M_from_M = shipM
        D_from_M = shipD
    Else
        M_from_D = shipM
        D_from_D = shipD
    End If
    
        
    End Sub

Private Sub Compute_CAN_Backlog_Flows( _
    ByVal A_Mon As Double, ByVal B_Mon As Double, _
    ByVal A_Tor As Double, ByVal B_Tor As Double, _
    ByVal A_Van As Double, ByVal B_Van As Double, _
    ByVal SH_Mon As Double, ByVal SH_Tor As Double, ByVal SH_Van As Double, _
    ByRef scenario As String, _
    ByRef Mon_from_Mon As Double, ByRef Mon_from_Tor As Double, ByRef Mon_from_Van As Double, _
    ByRef Tor_from_Mon As Double, ByRef Tor_from_Tor As Double, ByRef Tor_from_Van As Double, _
    ByRef Van_from_Mon As Double, ByRef Van_from_Tor As Double, ByRef Van_from_Van As Double)

    Const EPS As Double = 0.0000001

    '--- Defaults ---
    scenario = ""
    Mon_from_Mon = 0: Mon_from_Tor = 0: Mon_from_Van = 0
    Tor_from_Mon = 0: Tor_from_Tor = 0: Tor_from_Van = 0
    Van_from_Mon = 0: Van_from_Tor = 0: Van_from_Van = 0

    Dim A_Tot As Double, B_Tot As Double
    A_Tot = A_Mon + A_Tor + A_Van
    B_Tot = B_Mon + B_Tor + B_Van

    If A_Tot <= EPS Then
        If B_Tot <= EPS Then
            scenario = "CAN_0_NoData"
        Else
            scenario = "CAN_A1_NoSupply"
        End If
        Exit Sub
    End If

    If A_Tot + EPS >= B_Tot And B_Tot > EPS Then
        scenario = "CAN_A2_SupplyCoversAll"
    ElseIf B_Tot <= EPS Then
        scenario = "CAN_0_NoBacklog"
    Else
        scenario = "CAN_A3_ScarceSupply"
    End If

    '==================== 1) DESTINATION TOTALS via Share -> Cap -> Iterative Spill ====================
    Dim allocMon As Double, allocTor As Double, allocVan As Double
    Dim shipMon As Double, shipTor As Double, shipVan As Double

    allocMon = SH_Mon * A_Tot
    allocTor = SH_Tor * A_Tot
    allocVan = SH_Van * A_Tot

    shipMon = MinD(B_Mon, allocMon)
    shipTor = MinD(B_Tor, allocTor)
    shipVan = MinD(B_Van, allocVan)

    Dim used As Double, leftover As Double
    used = shipMon + shipTor + shipVan
    leftover = A_Tot - used

    Dim unmetMon As Double, unmetTor As Double, unmetVan As Double
    unmetMon = B_Mon - shipMon: If unmetMon < 0 Then unmetMon = 0
    unmetTor = B_Tor - shipTor: If unmetTor < 0 Then unmetTor = 0
    unmetVan = B_Van - shipVan: If unmetVan < 0 Then unmetVan = 0

    'Label cap pattern after first pass (informational)
    Dim capCount As Long
    capCount = 0
    If allocMon > B_Mon + EPS Then capCount = capCount + 1
    If allocTor > B_Tor + EPS Then capCount = capCount + 1
    If allocVan > B_Van + EPS Then capCount = capCount + 1

    If scenario = "CAN_A3_ScarceSupply" Then
        If capCount = 0 Then
            scenario = "CAN_B0_NoOneCapped"
        ElseIf capCount = 1 Then
            scenario = "CAN_B1_OneCapped"
        ElseIf capCount = 2 Then
            scenario = "CAN_B2_TwoCapped"
        Else
            scenario = "CAN_B3_AllCapped" 'rare; usually implies supply>=backlog
        End If
    End If

    'Iterative spill (Option 2: spill by remaining share weights among unmet cities)
    Dim guard As Long
    guard = 0

    Do While leftover > EPS And (unmetMon + unmetTor + unmetVan) > EPS And guard < 50
        guard = guard + 1

        Dim wMon As Double, wTor As Double, wVan As Double, wSum As Double
        wMon = 0: wTor = 0: wVan = 0

        If unmetMon > EPS Then wMon = SH_Mon
        If unmetTor > EPS Then wTor = SH_Tor
        If unmetVan > EPS Then wVan = SH_Van

        wSum = wMon + wTor + wVan
        If wSum <= EPS Then Exit Do

        Dim addMon As Double, addTor As Double, addVan As Double
        addMon = leftover * (wMon / wSum)
        addTor = leftover * (wTor / wSum)
        addVan = leftover * (wVan / wSum)

        'Cap adds by remaining unmet
        If addMon > unmetMon Then addMon = unmetMon
        If addTor > unmetTor Then addTor = unmetTor
        If addVan > unmetVan Then addVan = unmetVan

        shipMon = shipMon + addMon
        shipTor = shipTor + addTor
        shipVan = shipVan + addVan

        used = addMon + addTor + addVan
        leftover = leftover - used

        unmetMon = B_Mon - shipMon: If unmetMon < 0 Then unmetMon = 0
        unmetTor = B_Tor - shipTor: If unmetTor < 0 Then unmetTor = 0
        unmetVan = B_Van - shipVan: If unmetVan < 0 Then unmetVan = 0

        'If nothing moved, break to avoid infinite loop
        If used <= EPS Then Exit Do
    Loop

    '==================== 2) ROUTING: Local -> Partner1 -> Partner2 (conflicts split by remaining dest need) ====================
    'Partners (hard-coded as per your spec):
    ' Montreal: P1=Toronto,   P2=Vancouver
    ' Toronto:  P1=Montreal,  P2=Vancouver
    ' Vancouver:P1=Toronto,   P2=Montreal

    Dim remSrcMon As Double, remSrcTor As Double, remSrcVan As Double
    remSrcMon = A_Mon
    remSrcTor = A_Tor
    remSrcVan = A_Van

    Dim remDestMon As Double, remDestTor As Double, remDestVan As Double
    remDestMon = shipMon
    remDestTor = shipTor
    remDestVan = shipVan

    '--- Pass 0: Local ---
    Dim x As Double

    x = MinD(remSrcMon, remDestMon)
    Mon_from_Mon = Mon_from_Mon + x
    remSrcMon = remSrcMon - x
    remDestMon = remDestMon - x

    x = MinD(remSrcTor, remDestTor)
    Tor_from_Tor = Tor_from_Tor + x
    remSrcTor = remSrcTor - x
    remDestTor = remDestTor - x

    x = MinD(remSrcVan, remDestVan)
    Van_from_Van = Van_from_Van + x
    remSrcVan = remSrcVan - x
    remDestVan = remDestVan - x

    '--- Helper: allocate one source to up to 2 destination requests proportionally to remaining dest need ---
    'Toronto as source can be requested by Montreal (P1) and Vancouver (P1)
    'Montreal as source can be requested by Toronto (P1) and Vancouver (P2)
    'Vancouver as source can be requested by Montreal (P2) and Toronto (P2)

    '--- Pass 1: Partner 1 ---
    'Dest Montreal wants Toronto
    'Dest Toronto wants Montreal
    'Dest Vancouver wants Toronto
    Call AllocateSourceToDests(remSrcTor, remDestMon, remDestVan, Mon_from_Tor, Van_from_Tor)
    Call AllocateSourceToDests(remSrcMon, remDestTor, 0, Tor_from_Mon, x) 'second dest none

    '--- Pass 2: Partner 2 ---
    'Dest Montreal wants Vancouver
    'Dest Toronto wants Vancouver
    'Dest Vancouver wants Montreal
    Call AllocateSourceToDests(remSrcVan, remDestMon, remDestTor, Mon_from_Van, Tor_from_Van)
    Call AllocateSourceToDests(remSrcMon, remDestVan, 0, Van_from_Mon, x)

    'Done. Any remaining remDest* means not routable under this partner graph (should be rare in triangle).

End Sub

Private Sub AllocateSourceToDests( _
    ByRef remSource As Double, _
    ByRef remDest1 As Double, _
    ByRef remDest2 As Double, _
    ByRef flowToDest1 As Double, _
    ByRef flowToDest2 As Double)

    Const EPS As Double = 0.0000001

    If remSource <= EPS Then Exit Sub

    Dim need1 As Double, need2 As Double, needSum As Double
    need1 = remDest1: If need1 < 0 Then need1 = 0
    need2 = remDest2: If need2 < 0 Then need2 = 0
    needSum = need1 + need2

    If needSum <= EPS Then Exit Sub

    Dim alloc1 As Double, alloc2 As Double
    alloc1 = remSource * (need1 / needSum)
    alloc2 = remSource * (need2 / needSum)

    'Cap by remaining dest needs
    If alloc1 > remDest1 Then alloc1 = remDest1
    If alloc2 > remDest2 Then alloc2 = remDest2

    'If only one dest exists, give it everything it can take
    If remDest2 <= EPS Then
        alloc1 = MinD(remSource, remDest1)
        alloc2 = 0
    ElseIf remDest1 <= EPS Then
        alloc2 = MinD(remSource, remDest2)
        alloc1 = 0
    End If

    flowToDest1 = flowToDest1 + alloc1
    flowToDest2 = flowToDest2 + alloc2

    remDest1 = remDest1 - alloc1
    remDest2 = remDest2 - alloc2
    remSource = remSource - (alloc1 + alloc2)
End Sub



