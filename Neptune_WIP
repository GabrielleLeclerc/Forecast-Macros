Option Explicit

'========================= SETTINGS =========================
Public Const GATE_BY As String = "ENDING"          ' "ENDING" | "BEGINNING" | "EXISTING"
Public Const EPS_NEG As Double = 0                 ' Any value < EPS_NEG fails (0 = strictly negative fails)
Public Const IGNORE_MISSING_BOX_ROWS As Boolean = True
Public Const WRITE_DEBUG As Boolean = True

' How many boxes do you have total?
Public Const MAX_BOX As Long = 12                  ' Adjust as needed

' ---------- Per-sheet weekly column spans (letters) ----------
Public Const MTL_START_COL As String = "BN"
Public Const MTL_END_COL   As String = "EL"
Public Const TO_START_COL  As String = "BM"
Public Const TO_END_COL    As String = "EJ"
Public Const VAN_START_COL As String = "BN"
Public Const VAN_END_COL   As String = "EO"
Public Const IRN_START_COL As String = "BP"
Public Const IRN_END_COL   As String = "EU"
Public Const MOR_START_COL As String = "BP"
Public Const MOR_END_COL   As String = "EN"

' ---------- Core / Add-ons ----------
Private Function CoreGroup() As Variant
    CoreGroup = VBA.Array(1, 2, 3, 4, 5) ' core = 1..5
End Function

Private Function AddOnBoxes() As Variant
    Dim a() As Variant, b As Long, n As Long
    If MAX_BOX < 6 Then AddOnBoxes = VBA.Array(): Exit Function
    ReDim a(0 To MAX_BOX - 6)
    n = 0
    For b = 6 To MAX_BOX
        a(n) = b
        n = n + 1
    Next b
    AddOnBoxes = a
End Function

' ---------- Partner rules (priority order) ----------
Private Function PartnersFor(ByVal sheetName As String) As Variant
    Select Case sheetName
        Case "Neptune-Montreal":  PartnersFor = VBA.Array("Neptune-Toronto", "Neptune-Vancouver")
        Case "Neptune-Toronto":   PartnersFor = VBA.Array("Neptune-Montreal", "Neptune-Vancouver")
        Case "Neptune-Vancouver": PartnersFor = VBA.Array("Neptune-Montreal", "Neptune-Toronto")
        Case "Neptune-Ironlink":  PartnersFor = VBA.Array("Neptune-Moreno")
        Case "Neptune-Moreno":    PartnersFor = VBA.Array("Neptune-Ironlink")
        Case Else:                PartnersFor = VBA.Array()
    End Select
End Function

' Display names for sheet names
Private Function SheetCityName(ByVal sheetName As String) As String
    Select Case sheetName
        Case "Neptune-Montreal":  SheetCityName = "Montreal"
        Case "Neptune-Toronto":   SheetCityName = "Toronto"
        Case "Neptune-Vancouver": SheetCityName = "Vancouver"
        Case "Neptune-Ironlink":  SheetCityName = "Ironlink"
        Case "Neptune-Moreno":    SheetCityName = "Moreno"
        Case Else:                SheetCityName = sheetName
    End Select
End Function

' For outbound split label (not strictly required, but kept)
Private Sub OriginPartnerDisplay(ByVal originCity As String, ByRef p1Disp As String, ByRef p2Disp As String)
    Select Case originCity
        Case "Montreal":  p1Disp = "Toronto":  p2Disp = "Vancouver"
        Case "Toronto":   p1Disp = "Montreal": p2Disp = "Vancouver"
        Case "Vancouver": p1Disp = "Montreal": p2Disp = "Toronto"
        Case "Ironlink":  p1Disp = "Moreno":   p2Disp = ""
        Case "Moreno":    p1Disp = "Ironlink": p2Disp = ""
        Case Else:        p1Disp = "":         p2Disp = ""
    End Select
End Sub
'============================================================


'========================= ENTRY ============================
Public Sub BuildWeeklyBoxesShipped_ColsOnly()
    Const DBG_SHEET As String = "Boxes_Shipped_DEBUG"

    Dim dcSheets As Variant, dcNames As Variant
    dcSheets = VBA.Array("Neptune-Montreal", "Neptune-Toronto", "Neptune-Vancouver", "Neptune-Ironlink", "Neptune-Moreno")
    dcNames  = VBA.Array("Montreal", "Toronto", "Vancouver", "Ironlink", "Moreno")

    Dim wb As Workbook: Set wb = ThisWorkbook

    ' ===== Speed up =====
    Dim prevCalc As XlCalculation, prevScr As Boolean, prevEvt As Boolean
    prevCalc = Application.Calculation
    prevScr = Application.ScreenUpdating
    prevEvt = Application.EnableEvents
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.Calculation = xlCalculationManual

    On Error GoTo cleanup

    ' ===== Prepare output sheet =====
    Dim wsDbg As Worksheet: Set wsDbg = EnsureOutputSheet(wb, DBG_SHEET)
    wsDbg.Cells.Clear

    ' Header: Demand view + inbound breakdown + ONE outbound total on SAME ROW
    Dim hdr() As Variant, k As Long, iCol As Long
    ReDim hdr(1 To 8 + 2 * MAX_BOX + 10) ' +1 more for SalesTotal_New
    hdr(1) = "Demand City": hdr(2) = "Color": hdr(3) = "Week Start": hdr(4) = "Week End"
    hdr(5) = "Col":  hdr(6) = "GateBy": hdr(7) = "LocalCorePass": hdr(8) = "Reason"
    k = 8
    For iCol = 1 To MAX_BOX: k = k + 1: hdr(k) = "Raw B" & iCol: Next iCol
    For iCol = 1 To MAX_BOX: k = k + 1: hdr(k) = "EligLocal B" & iCol: Next iCol
    k = k + 1: hdr(k) = "SalesTotal"
    k = k + 1: hdr(k) = "SalesTotal_New"
    k = k + 1: hdr(k) = "FromLocal"
    k = k + 1: hdr(k) = "P1 City"
    k = k + 1: hdr(k) = "FromP1"
    k = k + 1: hdr(k) = "P2 City"
    k = k + 1: hdr(k) = "FromP2"
    k = k + 1: hdr(k) = "BoxesShipped"        ' Total number of boxes shipped across all FCs (Local + P1 + P2)
    k = k + 1: hdr(k) = "Pending"             ' Unfulfilled orders (SalesTotal - Boxes Shipped)
    k = k + 1: hdr(k) = "OutOfCityTotal"     ' *** Total boxes going OUT of this city (origin=this city)
    wsDbg.Cells(1, 1).Resize(1, UBound(hdr)).Value = hdr

    Dim dbgRow As Long: dbgRow = 2

    ' ===== In-memory ORIGIN summary aggregator (for OutOfCityTotal) =====
    Dim keys() As String, tot() As Double, cnt As Long, cap As Long
    cap = 256: cnt = 0
    ReDim keys(1 To cap)
    ReDim tot(1 To cap)

    ' ===== Cache demand rows (to fill OutOfCityTotal after aggregation is complete) =====
    Dim rowCache As Collection: Set rowCache = New Collection

    ' ===== Iterate DEMAND cities and decide who ships each box/qty =====
    Dim iCity As Long
    For iCity = LBound(dcSheets) To UBound(dcSheets)

        Dim demandSheet As String: demandSheet = CStr(dcSheets(iCity))
        Dim demandCity  As String: demandCity  = CStr(dcNames(iCity))
        If Not SheetExists(demandSheet) Then GoTo NextSheet

        Dim wsDC As Worksheet: Set wsDC = wb.Worksheets(demandSheet)

        ' Weekly span
        Dim cStart As Long, cEnd As Long
        GetFixedSpan demandSheet, cStart, cEnd
        If cStart <= 0 Or cEnd < cStart Then GoTo NextSheet

        ' Sections
        Dim salesTbl As Variant, gateTbl As Variant, begTbl As Variant
        salesTbl = BuildSectionTable_Block(wsDC, "Sales")
        begTbl   = BuildSectionTable_Block(wsDC, "Beginning Stock")

        Select Case UCase$(GATE_BY)
            Case "ENDING":    gateTbl = BuildSectionTable_Block(wsDC, "Ending Stock")
            Case "BEGINNING": gateTbl = begTbl
            Case "EXISTING":  gateTbl = BuildSectionTable_Block(wsDC, "Existing")
            Case Else:        gateTbl = BuildSectionTable_Block(wsDC, "Ending Stock")
        End Select

        Dim colors As Collection: Set colors = UnionColors(salesTbl, gateTbl, begTbl)
        If colors Is Nothing Or colors.Count = 0 Then GoTo NextSheet

        ' Partners for this demand city
        Dim partNames As Variant, hasPartners As Boolean, pLB As Long, pUB As Long
        partNames = PartnersFor(demandSheet)
        hasPartners = GetArrayBounds(partNames, pLB, pUB)

        Dim partners() As Worksheet, partnerGate() As Variant, p As Long
        If hasPartners Then
            ReDim partners(pLB To pUB)
            ReDim partnerGate(pLB To pUB)
            For p = pLB To pUB
                If SheetExists(CStr(partNames(p))) Then
                    Set partners(p) = wb.Worksheets(CStr(partNames(p)))
                    Select Case UCase$(GATE_BY)
                        Case "ENDING":    partnerGate(p) = BuildSectionTable_Block(partners(p), "Ending Stock")
                        Case "BEGINNING": partnerGate(p) = BuildSectionTable_Block(partners(p), "Beginning Stock")
                        Case "EXISTING":  partnerGate(p) = BuildSectionTable_Block(partners(p), "Existing")
                    End Select
                End If
            Next p
        End If

        ' Week columns
        Dim c As Long
        For c = cStart To cEnd

            If Not IsDate(wsDC.Cells(2, c).Value) Or Not IsDate(wsDC.Cells(4, c).Value) Then GoTo NextCol
            Dim wkStart As Date: wkStart = CDate(wsDC.Cells(2, c).Value)
            Dim wkEnd   As Date: wkEnd   = CDate(wsDC.Cells(4, c).Value)

            ' Colors
            Dim clr As Variant
            For Each clr In colors
                Dim colorRaw As String: colorRaw = CStr(clr)
                Dim colorKey As String: colorKey = NormalizeColor(colorRaw)

                ' ---- Reset per-row state ----
                Dim raw() As Double, eligLocal() As Double, allowedLocal() As Boolean
                ReDim raw(1 To MAX_BOX)
                ReDim eligLocal(1 To MAX_BOX)
                ReDim allowedLocal(1 To MAX_BOX)
                Dim b As Long, rr As Long, v As Double, salesTotal As Double
                Dim fromLocal As Double, fromP1 As Double, fromP2 As Double
                fromLocal = 0#: fromP1 = 0#: fromP2 = 0#

                ' ---- Raw demand (qty values) ----
                Dim salesTotalNew As Double
                salesTotalNew = 0#

                For b = 1 To MAX_BOX
                    rr = RowForInTable(salesTbl, colorKey, b)
                    If rr > 0 Then
                    ' Existing behavior: use the cell as-is (likely cumulative)
                    v = ValD(wsDC.Cells(rr, c).Value)
                If v > 0 Then raw(b) = v

                ' New behavior: weekly (non-cumulative) delta
                Dim vNow As Double, vPrev As Double, weekQty As Double
                vNow = v
                If c > cStart Then
                    vPrev = ValD(wsDC.Cells(rr, c - 1).Value)
                Else
                    vPrev = 0#
                End If
                weekQty = vNow - vPrev
                If weekQty > 0 Then
                    salesTotalNew = salesTotalNew + weekQty
                End If
            End If

            ' Keep original cumulative SalesTotal logic
            salesTotal = salesTotal + raw(b)
        Next b
                If salesTotal <= 0 Then GoTo NextColor

                ' ---- Local gating ----
                Dim corePass As Boolean, reason As String
                AllowedBoxesForDC_Single wsDC, gateTbl, colorKey, c, CoreGroup(), corePass, reason, allowedLocal

                ' ---- Cover locally first ----
                For b = 1 To MAX_BOX
                    If raw(b) > 0 And allowedLocal(b) Then
                        eligLocal(b) = raw(b)
                        fromLocal = fromLocal + raw(b)
                        ' ORIGIN = demand city (shipping to itself)
                        UpdateOriginAgg keys, tot, cnt, cap, demandCity, demandCity, colorKey, wkStart, wkEnd, raw(b)
                    End If
                Next b

                ' ---- Cover remaining with partners in order; first eligible wins ----
                If hasPartners Then
                    Dim p1Start As Long, p1End As Long, p1Col As Long, off1 As Long
                    Dim p2Start As Long, p2End As Long, p2Col As Long, off2 As Long

                    ' Partner 1
                    Dim allowedP1() As Boolean, p1Pass As Boolean, rz1 As String
                    Dim hasP1 As Boolean: hasP1 = False
                    If Not partners(pLB) Is Nothing Then
                        GetFixedSpan partners(pLB).Name, p1Start, p1End
                        off1 = c - cStart: p1Col = p1Start + off1
                        If p1Col >= p1Start And p1Col <= p1End Then
                            ReDim allowedP1(1 To MAX_BOX)
                            AllowedBoxesForDC_Single partners(pLB), partnerGate(pLB), colorKey, p1Col, CoreGroup(), p1Pass, rz1, allowedP1
                            hasP1 = True
                            If p1Pass Then
                                For b = 1 To MAX_BOX
                                    If raw(b) > 0 And Not allowedLocal(b) And allowedP1(b) Then
                                        fromP1 = fromP1 + raw(b)
                                        ' ORIGIN = partner1 shipping to demand city
                                        UpdateOriginAgg keys, tot, cnt, cap, SheetCityName(partners(pLB).Name), demandCity, colorKey, wkStart, wkEnd, raw(b)
                                    End If
                                Next b
                            End If
                        End If
                    End If

                    ' Partner 2
                    If pUB >= pLB + 1 Then
                        If Not partners(pLB + 1) Is Nothing Then
                            Dim allowedP2() As Boolean, p2Pass As Boolean, rz2 As String
                            GetFixedSpan partners(pLB + 1).Name, p2Start, p2End
                            off2 = c - cStart: p2Col = p2Start + off2
                            If p2Col >= p2Start And p2Col <= p2End Then
                                ReDim allowedP2(1 To MAX_BOX)
                                AllowedBoxesForDC_Single partners(pLB + 1), partnerGate(pLB + 1), colorKey, p2Col, CoreGroup(), p2Pass, rz2, allowedP2
                                If p2Pass Then
                                    For b = 1 To MAX_BOX
                                        Dim coveredByP1 As Boolean: coveredByP1 = False
                                        If hasP1 And p1Pass Then coveredByP1 = allowedP1(b)
                                        If raw(b) > 0 And Not allowedLocal(b) And Not coveredByP1 And allowedP2(b) Then
                                            fromP2 = fromP2 + raw(b)
                                            ' ORIGIN = partner2 shipping to demand city
                                            UpdateOriginAgg keys, tot, cnt, cap, SheetCityName(partners(pLB + 1).Name), demandCity, colorKey, wkStart, wkEnd, raw(b)
                                        End If
                                    Next b
                                End If
                            End If
                        End If
                    End If
                End If

                ' ---- Stash row for later write (after we know OutOfCityTotal) ----
                Dim rowArr() As Variant, idx As Long
                ReDim rowArr(1 To 8 + 2 * MAX_BOX + 10) ' +1 for SalesTotal_New
                rowArr(1) = demandCity: rowArr(2) = colorRaw
                rowArr(3) = wkStart:    rowArr(4) = wkEnd
                rowArr(5) = ColN2L(c):  rowArr(6) = UCase$(GATE_BY)
                rowArr(7) = corePass:   rowArr(8) = reason
                idx = 8
                Dim bb As Long
                For bb = 1 To MAX_BOX: idx = idx + 1: rowArr(idx) = raw(bb):       Next bb
                For bb = 1 To MAX_BOX: idx = idx + 1: rowArr(idx) = eligLocal(bb): Next bb
                idx = idx + 1: rowArr(idx) = salesTotal
                idx = idx + 1: rowArr(idx) = salesTotalNew
                Dim p1Name As String, p2Name As String
                p1Name = "": p2Name = ""
                If hasPartners Then
                    If Not partners(pLB) Is Nothing Then p1Name = SheetCityName(partners(pLB).Name)
                    If pUB >= pLB + 1 Then If Not partners(pLB + 1) Is Nothing Then p2Name = SheetCityName(partners(pLB + 1).Name)
                End If
                idx = idx + 1: rowArr(idx) = fromLocal
                idx = idx + 1: rowArr(idx) = p1Name
                idx = idx + 1: rowArr(idx) = fromP1
                idx = idx + 1: rowArr(idx) = p2Name
                idx = idx + 1: rowArr(idx) = fromP2
                Dim boxesShipped As Double, pending As Double
                boxesShipped = fromLocal + fromP1 + fromP2
                pending = salesTotal - boxesShipped
                idx = idx + 1: rowArr(idx) = boxesShipped   ' BoxesShipped
                idx = idx + 1: rowArr(idx) = pending        ' Pending
                idx = idx + 1: rowArr(idx) = 0#             ' OutOfCityTotal (filled later; stays LAST)
                ' Save normalized color key with the row
                rowCache.Add Array(rowArr, colorKey)

NextColor:
            Next clr

NextCol:
        Next c

NextSheet:
    Next iCity

    ' ===== Now write rows, filling OutOfCityTotal from aggregator =====
    Dim it As Variant, outKey As String, outIdx As Long
    For Each it In rowCache
        Dim rArr() As Variant: rArr = it(0)
        Dim outColorKey As String: outColorKey = it(1)         ' <â€” renamed to avoid duplicate declaration
        outKey = MakeKey(CStr(rArr(1)), outColorKey, CDate(rArr(3)), CDate(rArr(4)))
        outIdx = FindKeyIndex(keys, cnt, outKey)
        If outIdx > 0 Then
            rArr(UBound(rArr)) = tot(outIdx)
        Else
            rArr(UBound(rArr)) = 0#
        End If
        wsDbg.Cells(dbgRow, 1).Resize(1, UBound(rArr)).Value = rArr
        dbgRow = dbgRow + 1
    Next it

    ' Format
    With wsDbg
        .Columns("A:ZZ").AutoFit
        If dbgRow > 2 Then .Range("C2:D" & dbgRow - 1).NumberFormat = "yyyy-mm-dd"
    End With

    MsgBox "Done. SalesTotal_New is on each row.", vbInformation

cleanup:
    Application.Calculation = prevCalc
    Application.EnableEvents = prevEvt
    Application.ScreenUpdating = prevScr
End Sub
'============================================================


'======================= ORIGIN AGG (for OutOfCityTotal) ===========================
Private Sub UpdateOriginAgg(ByRef keys() As String, ByRef tot() As Double, _
                            ByRef cnt As Long, ByRef cap As Long, _
                            ByVal originCity As String, ByVal demandCity As String, _
                            ByVal colorKey As String, ByVal wkStart As Date, ByVal wkEnd As Date, _
                            ByVal qty As Double)
    Dim key As String
    key = MakeKey(originCity, colorKey, wkStart, wkEnd)
    Dim idx As Long: idx = FindKeyIndex(keys, cnt, key)
    If idx = 0 Then
        cnt = cnt + 1
        If cnt > cap Then
            cap = cap * 2
            ReDim Preserve keys(1 To cap)
            ReDim Preserve tot(1 To cap)
        End If
        idx = cnt
        keys(idx) = key
        tot(idx) = 0#
    End If
    tot(idx) = tot(idx) + qty
End Sub

Private Function MakeKey(ByVal city As String, ByVal colorKey As String, ByVal wkStart As Date, ByVal wkEnd As Date) As String
    MakeKey = UCase$(Trim$(city)) & "|" & UCase$(Trim$(colorKey)) & "|" & _
              Format$(wkStart, "yyyy-mm-dd") & "|" & Format$(wkEnd, "yyyy-mm-dd")
End Function

Private Function FindKeyIndex(ByRef keys() As String, ByVal cnt As Long, ByVal key As String) As Long
    Dim i As Long
    For i = 1 To cnt
        If keys(i) = key Then FindKeyIndex = i: Exit Function
    Next i
End Function
'=============================================================================


'======================= COMMON HELPERS ============================
Private Sub GetFixedSpan(ByVal sheetName As String, ByRef startCol As Long, ByRef endCol As Long)
    Dim sStart As String, sEnd As String
    Select Case sheetName
        Case "Neptune-Montreal":  sStart = MTL_START_COL: sEnd = MTL_END_COL
        Case "Neptune-Toronto":   sStart = TO_START_COL:  sEnd = TO_END_COL
        Case "Neptune-Vancouver": sStart = VAN_START_COL: sEnd = VAN_END_COL
        Case "Neptune-Ironlink":  sStart = IRN_START_COL: sEnd = IRN_END_COL
        Case "Neptune-Moreno":    sStart = MOR_START_COL: sEnd = MOR_END_COL
    End Select
    startCol = ColLetterToNumber(sStart)
    endCol   = ColLetterToNumber(sEnd)
End Sub

Private Function ColLetterToNumber(ByVal colLetters As String) As Long
    Dim s As String: s = UCase$(Trim$(colLetters))
    Dim i As Long, n As Long
    For i = 1 To Len(s)
        If Mid$(s, i, 1) < "A" Or Mid$(s, i, 1) > "Z" Then Exit For
        n = n * 26 + (Asc(Mid$(s, i, 1)) - Asc("A") + 1)
    Next i
    ColLetterToNumber = n
End Function

Private Function ColN2L(ByVal n As Long) As String
    Dim s As String, r As Long
    Do While n > 0
        r = (n - 1) Mod 26
        s = Chr$(Asc("A") + r) & s
        n = (n - 1) \ 26
    Loop
    ColN2L = s
End Function

Private Function EnsureOutputSheet(wb As Workbook, ByVal name As String) As Worksheet
    If SheetExists(name) Then
        Set EnsureOutputSheet = wb.Worksheets(name)
    Else
        Set EnsureOutputSheet = wb.Worksheets.Add(After:=wb.Worksheets(wb.Worksheets.Count))
        EnsureOutputSheet.Name = name
    End If
End Function

Private Function SheetExists(ByVal name As String) As Boolean
    On Error Resume Next
    SheetExists = Not ThisWorkbook.Worksheets(name) Is Nothing
    On Error GoTo 0
End Function

Private Function NormalizeColor(ByVal s As String) As String
    Dim t As String
    t = CStr(s)
    t = Replace(t, Chr(160), " ")
    On Error Resume Next: t = Replace(t, ChrW(160), " "): On Error GoTo 0
    On Error Resume Next: t = WorksheetFunction.Trim(WorksheetFunction.Clean(t)): On Error GoTo 0
    NormalizeColor = UCase$(Trim$(t))
End Function

Private Function BuildSectionTable_Block(ws As Worksheet, ByVal sectionName As String) As Variant
    Dim lastRow As Long: lastRow = ws.Cells(ws.Rows.Count, "C").End(xlUp).Row
    Dim r As Long, rStart As Long, rEnd As Long

    For r = 1 To lastRow
        If UCase$(Trim$(CStr(ws.Cells(r, "C").Value))) = UCase$(sectionName) Then
            rStart = r + 1
            Exit For
        End If
    Next r
    If rStart = 0 Then BuildSectionTable_Block = Empty: Exit Function

    rEnd = lastRow
    For r = rStart To lastRow
        Dim hdr As String: hdr = UCase$(Trim$(CStr(ws.Cells(r, "C").Value)))
        If (hdr = "BEGINNING STOCK") Or (hdr = "ENDING STOCK") Or (hdr = "SALES") Or (hdr = "EXISTING") Or (hdr = "TO BE RECEIVED") Then
            If r > rStart Then rEnd = r - 1
            Exit For
        End If
    Next r

    Dim tmp() As Variant, cnt As Long: ReDim tmp(1 To 3, 1 To 1)
    Dim lastColorKey As String: lastColorKey = ""

    For r = rStart To rEnd
        Dim desc As String: desc = CStr(ws.Cells(r, "D").Value)
        Dim bx As Long: bx = ParseBoxNum(desc)
        If bx = 0 Then GoTo NextRow

        ' ignore "Box 8 - NEW ARMS/SRMS"
        If bx = 8 Then
            Dim U8 As String: U8 = UCase$(desc)
            If (InStr(1, U8, "NEW") > 0) And (InStr(1, U8, "ARMS") > 0 Or InStr(1, U8, "SRMS") > 0) Then GoTo NextRow
        End If

        Dim colorRaw As String, colorKey As String
        colorRaw = CStr(ws.Cells(r, "E").Value)
        colorKey = ""
        If IsLikelyColor(colorRaw) Then colorKey = NormalizeColor(colorRaw)
        If Len(colorKey) = 0 And Len(lastColorKey) > 0 Then colorKey = lastColorKey
        If Len(colorKey) = 0 Then GoTo NextRow
        lastColorKey = colorKey

        cnt = cnt + 1
        If cnt > UBound(tmp, 2) Then ReDim Preserve tmp(1 To 3, 1 To cnt)
        tmp(1, cnt) = colorKey
        tmp(2, cnt) = bx
        tmp(3, cnt) = r
NextRow:
    Next r

    If cnt = 0 Then BuildSectionTable_Block = Empty Else BuildSectionTable_Block = tmp
End Function

Private Function IsLikelyColor(ByVal v As Variant) As Boolean
    Dim s As String: s = Trim$(CStr(v))
    If Len(s) = 0 Then Exit Function
    If IsNumeric(s) Then Exit Function
    On Error Resume Next
    If IsDate(s) Then Exit Function
    On Error GoTo 0
    Dim i As Long, ch As String
    For i = 1 To Len(s)
        ch = Mid$(s, i, 1)
        If ch Like "[A-Za-z]" Then IsLikelyColor = True: Exit Function
    Next i
End Function

Private Function ParseBoxNum(ByVal s As String) As Long
    Dim U As String: U = UCase$(s)
    Dim p As Long: p = InStr(1, U, "BOX")
    If p = 0 Then Exit Function
    Dim i As Long, ch As String, numStr As String
    For i = p + 3 To Len(U)
        ch = Mid$(U, i, 1)
        If ch = " " Or ch = "-" Or ch = ChrW(8211) Or ch = ChrW(8212) Or ch = ChrW(160) Then
            ' skip
        ElseIf ch Like "#" Then
            numStr = numStr & ch
        ElseIf Len(numStr) > 0 Then
            Exit For
        End If
    Next i
    If Len(numStr) > 0 Then ParseBoxNum = CLng(numStr)
End Function

Private Function RowForInTable(tbl As Variant, ByVal colorKey As String, ByVal boxNum As Long) As Long
    If IsEmpty(tbl) Then Exit Function
    Dim i As Long
    For i = 1 To UBound(tbl, 2)
        If CStr(tbl(1, i)) = colorKey And CLng(tbl(2, i)) = boxNum Then
            RowForInTable = CLng(tbl(3, i))
            Exit Function
        End If
    Next i
End Function

Private Function UnionColors(ParamArray tbls() As Variant) As Collection
    Dim c As New Collection, t As Variant, i As Long, clr As String
    On Error GoTo done
    For Each t In tbls
        If Not IsEmpty(t) Then
            For i = 1 To UBound(t, 2)
                clr = CStr(t(1, i))
                If Len(clr) > 0 Then On Error Resume Next: c.Add clr, clr: On Error GoTo 0
            Next i
        End If
    Next t
done:
    Set UnionColors = c
End Function

' ==== Single-group gating + add-ons ====
Private Sub AllowedBoxesForDC_Single(ws As Worksheet, gateTbl As Variant, ByVal key As String, ByVal colIdx As Long, ByRef coreGrp As Variant, ByRef passCore As Boolean, ByRef reason As String, ByRef allowed() As Boolean)
    Dim b As Long
    ReDim allowed(1 To MAX_BOX)
    For b = 1 To MAX_BOX: allowed(b) = False: Next b

    passCore = SectionAvailable_Table(ws, gateTbl, key, colIdx, coreGrp, reason)

    If passCore Then
        Dim k As Long
        For k = LBound(coreGrp) To UBound(coreGrp)
            b = CLng(coreGrp(k))
            If b >= 1 And b <= MAX_BOX Then allowed(b) = True
        Next k
        Dim ao As Variant
        For Each ao In AddOnBoxes()
            b = CLng(ao)
            If b >= 1 And b <= MAX_BOX Then allowed(b) = True
        Next ao
    End If
End Sub

Private Function SectionAvailable_Table(ws As Worksheet, gateTbl As Variant, ByVal colorKey As String, ByVal colIdx As Long, ByRef grp As Variant, ByRef reason As String) As Boolean
    reason = ""
    If IsEmpty(gateTbl) Then reason = "Gate section not found": Exit Function

    Dim hasAny As Boolean, k As Long, b As Long, r As Long, v As Double
    For k = LBound(grp) To UBound(grp)
        b = CLng(grp(k))
        r = RowForInTable(gateTbl, colorKey, b)
        If r = 0 Then
            If IGNORE_MISSING_BOX_ROWS Then
                ' skip
            Else
                reason = "Missing box " & b & " row"
                Exit Function
            End If
        Else
            hasAny = True
            v = ValD(ws.Cells(r, colIdx).Value)
            If v < EPS_NEG Then
                reason = "Box " & b & " < 0 at " & ws.Name & "!" & ws.Cells(r, colIdx).Address(False, False)
                Exit Function
            End If
        End If
    Next k

    If Not hasAny Then reason = "No boxes from group found": Exit Function
    SectionAvailable_Table = True
End Function

' Robust numeric parser
Private Function ValD(ByVal v As Variant) As Double
    On Error GoTo fail

    If Not IsError(v) And Not IsNull(v) Then
        If IsNumeric(v) Then ValD = CDbl(v): Exit Function
    End If

    Dim s As String
    s = CStr(v)
    s = Replace(s, Chr$(160), " ")
    On Error Resume Next: s = Replace(s, ChrW$(160), " "): On Error GoTo 0
    s = Replace(s, ",", "")
    s = Trim$(s)
    If Len(s) = 0 Then Exit Function

    ' normalize various minus characters
    s = Replace(s, ChrW$(8722), "-")
    s = Replace(s, ChrW$(8211), "-")
    s = Replace(s, ChrW$(8212), "-")
    s = Replace(s, ChrW$(8210), "-")

    If Left$(s, 1) = "(" And Right$(s, 1) = ")" Then s = "-" & Mid$(s, 2, Len(s) - 2)

    s = Replace(s, "$", "")
    s = Replace(s, " ", "")
    If Right$(s, 1) = "%" Then s = Left$(s, Len(s) - 1)

    If IsNumeric(s) Then ValD = CDbl(s): Exit Function

fail:
    ValD = 0#
End Function

' Safe bounds for VBA.Array (handles empty)
Private Function GetArrayBounds(ByVal arr As Variant, ByRef lb As Long, ByRef ub As Long) As Boolean
    On Error Resume Next
    lb = LBound(arr): ub = UBound(arr)
    GetArrayBounds = (Err.Number = 0 And ub >= lb)
    Err.Clear
    On Error GoTo 0
End Function
'============================================================
