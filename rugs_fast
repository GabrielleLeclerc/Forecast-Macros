Option Explicit

'============================= SETTINGS =============================

Private Const OUT_SHEET As String = "Rugs_Shipped_Weekly"
Private Const DBG_SHEET As String = "Rugs_Shipped_DEBUG"

' Sheets in scope (order defines output city order)
Private dcSheets As Variant, dcNames As Variant, skuColLetters As Variant

' Section labels (must match cell text in column B; case-insensitive)
Private Const LBL_BEGIN As String = "BEGINNING STOCK"
Private Const LBL_END   As String = "ENDING STOCK"
Private Const LBL_SALES As String = "SALES"
Private Const LBL_PO    As String = "PO TO BE RECEIVED" ' in your file: "PO to be received"

' Column where section headers are found
Private Const HEADER_COL As String = "B"

'============================= WEEK COLUMN LIMITS =============================

Private Const MTL_START_COL As String = "CT"  ' Week of 2025-12-01
Private Const MTL_END_COL   As String = "FC"
Private Const TO_START_COL  As String = "CS"  ' Week of 2025-12-01
Private Const TO_END_COL    As String = "EY"
Private Const VAN_START_COL As String = "CT"  ' Week of 2025-12-01
Private Const VAN_END_COL   As String = "EY"
Private Const DAY_START_COL As String = "CS"  ' Week of 2025-12-01
Private Const DAY_END_COL   As String = "EY"
Private Const MOR_START_COL As String = "CS"  ' Week of 2025-12-01
Private Const MOR_END_COL   As String = "EY"


'============================= ENTRY =============================

Public Sub BuildWeeklyRugs_Shipped_LabelLocked()
    InitConfig

    Dim wb As Workbook: Set wb = ThisWorkbook
    Dim i As Long, c As Long
    Dim wkKey As String
    Dim wkEnd As Date


    ' ---- speedup toggles ----
    Dim scrState As Boolean, evtState As Boolean, calcState As XlCalculation
    scrState = Application.ScreenUpdating
    evtState = Application.EnableEvents
    calcState = Application.Calculation
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.Calculation = xlCalculationManual
    On Error GoTo CleanFail
    ' -------------------------

    ' Validate sheets
    For i = LBound(dcSheets) To UBound(dcSheets)
        If Not SheetExists(CStr(dcSheets(i))) Then
            MsgBox "Missing sheet: " & CStr(dcSheets(i)), vbExclamation
            GoTo CleanDone
        End If
    Next i

    ' Bind sheets
    Dim wsDC() As Worksheet
    ReDim wsDC(LBound(dcSheets) To UBound(dcSheets))
    For i = LBound(dcSheets) To UBound(dcSheets)
        Set wsDC(i) = wb.Worksheets(CStr(dcSheets(i)))
    Next i

    ' Discover section ranges by label per sheet
    Dim begS() As Long, begE() As Long
    Dim salesS() As Long, salesE() As Long
    Dim poS() As Long, poE() As Long

    ReDim begS(LBound(dcSheets) To UBound(dcSheets))
    ReDim begE(LBound(dcSheets) To UBound(dcSheets))
    ReDim salesS(LBound(dcSheets) To UBound(dcSheets))
    ReDim salesE(LBound(dcSheets) To UBound(dcSheets))
    ReDim poS(LBound(dcSheets) To UBound(dcSheets))
    ReDim poE(LBound(dcSheets) To UBound(dcSheets))

    For i = LBound(dcSheets) To UBound(dcSheets)
        If Not GetSectionRange(wsDC(i), LBL_BEGIN, begS(i), begE(i)) Then
            MsgBox "Couldn't find section '" & LBL_BEGIN & "' on " & wsDC(i).name, vbExclamation
            GoTo CleanDone
        End If
        If Not GetSectionRange(wsDC(i), LBL_SALES, salesS(i), salesE(i)) Then
            MsgBox "Couldn't find section '" & LBL_SALES & "' on " & wsDC(i).name, vbExclamation
            GoTo CleanDone
        End If
        If Not GetSectionRange(wsDC(i), LBL_PO, poS(i), poE(i)) Then
            MsgBox "Couldn't find section '" & LBL_PO & "' on " & wsDC(i).name, vbExclamation
            GoTo CleanDone
        End If
    Next i

    ' Build week column maps per DC + union of weeks (wkStart)
    Dim weekCol() As Collection
    ReDim weekCol(LBound(dcSheets) To UBound(dcSheets))
    Dim weekStarts As Collection: Set weekStarts = New Collection
    Dim weekEndByKey As Collection: Set weekEndByKey = New Collection ' wkKey -> weekEnd

    For i = LBound(dcSheets) To UBound(dcSheets)
    Set weekCol(i) = New Collection
    Dim lastCol As Long: lastCol = wsDC(i).UsedRange.Columns(wsDC(i).UsedRange.Columns.Count).Column

    Dim firstCol As Long, endCol As Long
    firstCol = WeekStartColBySheet(CStr(dcSheets(i)))
    endCol = WeekEndColBySheet(CStr(dcSheets(i)), lastCol)

    For c = firstCol To endCol
        Dim wkStart As Date: wkStart = WeekStartAt(wsDC(i), c)
        If wkStart > 0 Then
            wkKey = Format$(wkStart, "yyyymmdd")
            MapSet weekCol(i), wkKey, c
            AddUniqueDate weekStarts, wkStart

            wkEnd = WeekEndAt(wsDC(i), c)
            If wkEnd > 0 Then
                If Not MapExists(weekEndByKey, wkKey) Then MapSet weekEndByKey, wkKey, wkEnd
            End If
        End If
    Next c
Next i


    If weekStarts.Count = 0 Then
        MsgBox "No week start dates found in row 2.", vbExclamation
        GoTo CleanDone
    End If

    ' Sort weeks
    Dim wkArr() As Date
    wkArr = CollDatesToArray(weekStarts)
    SortDates wkArr

    ' Prepare output sheets
    Dim wsOut As Worksheet: Set wsOut = EnsureOutputSheet(wb, OUT_SHEET)
    Dim wsDbg As Worksheet: Set wsDbg = EnsureOutputSheet(wb, DBG_SHEET)

    wsOut.Cells.Clear
    wsDbg.Cells.Clear

    wsOut.Range("A1:E1").Value = Array("City", "Week Start", "Week End", "Shipped", "Unfulfilled")
    wsDbg.Range("A1:N1").Value = Array( _
    "City", "Week Start", "Week End", _
    "Backlog", _
    "Sales_Total", _
    "Effective_Demand", _
    "ShippedFromLocal", _
    "P1 City", "ShippedFromP1", _
    "P2 City", "ShippedFromP2", _
    "Boxes_Shipped", _
    "Unfulfilled", _
    "OutOfCityTotal" _
)





    ' Output buffers
    Dim cityCount As Long: cityCount = UBound(dcSheets) - LBound(dcSheets) + 1
    Dim weekCount As Long: weekCount = UBound(wkArr) - LBound(wkArr) + 1
    Dim outRows As Long: outRows = cityCount * weekCount

    Dim outArr() As Variant: ReDim outArr(1 To outRows, 1 To 5)
    Dim dbgArr() As Variant: ReDim dbgArr(1 To outRows, 1 To 14)

    Dim outPtr As Long: outPtr = 1
    Dim w As Long, j As Long
    
    '==================== NEW: persistent backlog per city (SKU-specific) ====================
    Dim backlogByCity() As Collection, backlogKeysByCity() As Collection
    ReDim backlogByCity(LBound(dcSheets) To UBound(dcSheets))
    ReDim backlogKeysByCity(LBound(dcSheets) To UBound(dcSheets))
        
    For j = LBound(dcSheets) To UBound(dcSheets)
        Set backlogByCity(j) = New Collection        ' sku -> qty
        Set backlogKeysByCity(j) = New Collection    ' list of sku keys in backlog
    Next j

    '========================================================================================


    ' ===== Per-week loop =====
    For w = LBound(wkArr) To UBound(wkArr)
        wkKey = Format$(wkArr(w), "yyyymmdd")
        wkEnd = MapGetDate(weekEndByKey, wkKey, 0)
    Dim skuKey As String


        ' Totals per DC
        Dim shippedByDC() As Double, shippedLocalByDC() As Double
        Dim unfulByDC() As Double, salesByDC() As Double, availByDC() As Double
        Dim backlogTotalByDC() As Double, effectiveDemandByDC() As Double
        Dim outOfCityByDC() As Double

        
        ReDim shippedByDC(LBound(dcSheets) To UBound(dcSheets))
        ReDim shippedLocalByDC(LBound(dcSheets) To UBound(dcSheets))
        ReDim unfulByDC(LBound(dcSheets) To UBound(dcSheets))
        ReDim salesByDC(LBound(dcSheets) To UBound(dcSheets))
        ReDim availByDC(LBound(dcSheets) To UBound(dcSheets))
        ReDim backlogTotalByDC(LBound(dcSheets) To UBound(dcSheets))
        ReDim effectiveDemandByDC(LBound(dcSheets) To UBound(dcSheets))
        ReDim outOfCityByDC(LBound(dcSheets) To UBound(dcSheets))


'==================== NEW: partner shipment totals per demand city ====================
Dim shippedFromPartnerByDemand() As Collection
ReDim shippedFromPartnerByDemand(LBound(dcSheets) To UBound(dcSheets))

For j = LBound(dcSheets) To UBound(dcSheets)
    Set shippedFromPartnerByDemand(j) = New Collection
Next j
'=====================================================================================


        '==================== PHASE A: Read Sales/Beg/PO maps for ALL cities ====================

Dim mSalesByCity() As Collection, mBegByCity() As Collection, mPOByCity() As Collection
Dim salesKeysByCity() As Collection

ReDim mSalesByCity(LBound(dcSheets) To UBound(dcSheets))
ReDim mBegByCity(LBound(dcSheets) To UBound(dcSheets))
ReDim mPOByCity(LBound(dcSheets) To UBound(dcSheets))
ReDim salesKeysByCity(LBound(dcSheets) To UBound(dcSheets))

For j = LBound(dcSheets) To UBound(dcSheets)

    Dim colW As Long
    colW = MapGetLong(weekCol(j), wkKey, 0)

    Set salesKeysByCity(j) = New Collection
    Set mSalesByCity(j) = New Collection
    Set mBegByCity(j) = New Collection
    Set mPOByCity(j) = New Collection

    If colW > 0 Then
        Dim skuCol As Long
        skuCol = ColLetterToNumber(CStr(skuColLetters(j)))

        Set mSalesByCity(j) = SumSectionBySkuMap(wsDC(j), salesS(j), salesE(j), skuCol, colW, salesKeysByCity(j))
        Set mBegByCity(j) = SumSectionBySkuMap(wsDC(j), begS(j), begE(j), skuCol, colW, Nothing)
        Set mPOByCity(j) = SumSectionBySkuMap(wsDC(j), poS(j), poE(j), skuCol, colW, Nothing)
    End If
Next j

'==================== PHASE B: Local shipping first + store remaining demand ====================

' selfShipByCity(j): how much city j used to cover its OWN demand per SKU
' remDemandByCity(j): remaining demand per SKU after local shipping
' donatedByCity(j): how much city j has already donated to others per SKU
Dim selfShipByCity() As Collection, remDemandByCity() As Collection, donatedByCity() As Collection
Dim remKeysByCity() As Collection
ReDim remKeysByCity(LBound(dcSheets) To UBound(dcSheets))
ReDim selfShipByCity(LBound(dcSheets) To UBound(dcSheets))
ReDim remDemandByCity(LBound(dcSheets) To UBound(dcSheets))
ReDim donatedByCity(LBound(dcSheets) To UBound(dcSheets))

For j = LBound(dcSheets) To UBound(dcSheets)
    Set selfShipByCity(j) = New Collection
    Set remDemandByCity(j) = New Collection
    Set donatedByCity(j) = New Collection
    Set remKeysByCity(j) = New Collection

    Dim k As Variant
    Dim processKeys As Collection
    Set processKeys = New Collection
    
    ' add sales SKUs
    Dim tmp As Variant
    For Each tmp In salesKeysByCity(j)
        AddUniqueKey processKeys, CStr(tmp)
    Next tmp
    
    ' add backlog-only SKUs
    For Each tmp In backlogKeysByCity(j)
        AddUniqueKey processKeys, CStr(tmp)
    Next tmp
    
    ' now process union
    For Each k In processKeys


        skuKey = CStr(k)

        Dim salesV As Double, begV As Double, poV As Double, availV As Double
        Dim shipLocal As Double, remaining As Double

        salesV = MapGetDbl(mSalesByCity(j), skuKey, 0#)
        If salesV < 0# Then salesV = 0#

        begV = MapGetDbl(mBegByCity(j), skuKey, 0#)
        poV = MapGetDbl(mPOByCity(j), skuKey, 0#)
        If begV < 0# Then begV = 0#
        If poV < 0# Then poV = 0#

        availV = begV + poV

        Dim backlogSku As Double, demandV As Double
        backlogSku = MapGetDbl(backlogByCity(j), skuKey, 0#)
        
        demandV = salesV + backlogSku
        backlogTotalByDC(j) = backlogTotalByDC(j) + backlogSku
        effectiveDemandByDC(j) = effectiveDemandByDC(j) + demandV
        
        If demandV < availV Then shipLocal = demandV Else shipLocal = availV
        remaining = demandV - shipLocal
        If remaining < 0# Then remaining = 0#


        ' totals for output/debug
        salesByDC(j) = salesByDC(j) + salesV
        availByDC(j) = availByDC(j) + availV
        shippedByDC(j) = shippedByDC(j) + shipLocal
        shippedLocalByDC(j) = shippedLocalByDC(j) + shipLocal
        unfulByDC(j) = unfulByDC(j) + remaining

        ' store per-SKU for partner logic
        If shipLocal <> 0# Then MapSet selfShipByCity(j), skuKey, shipLocal
        If remaining <> 0# Then
            MapSet remDemandByCity(j), skuKey, remaining
            AddUniqueKey remKeysByCity(j), skuKey
        End If


    Next k
Next j

'==================== PHASE C: Partner allocation (uses partner leftover AFTER own demand) ====================

For j = LBound(dcSheets) To UBound(dcSheets)

    Dim partners As Variant
    partners = PartnersFor(CStr(dcSheets(j)))

    Dim sku As Variant
    For Each sku In remKeysByCity(j)


        skuKey = CStr(sku)

        Dim need As Double
        need = MapGetDbl(remDemandByCity(j), skuKey, 0#)
        If need <= 0# Then GoTo NextSkuPartner

        Dim p As Long
        For p = LBound(partners) To UBound(partners)

            Dim pSheet As String: pSheet = CStr(partners(p))
            Dim pj As Long: pj = FindDCIndexBySheetName(pSheet)
            If pj < 0 Then GoTo NextPartner

            ' partner total availability for this SKU
            Dim pBegV As Double, pPoV As Double, pAvail As Double
            pBegV = MapGetDbl(mBegByCity(pj), skuKey, 0#)
            pPoV = MapGetDbl(mPOByCity(pj), skuKey, 0#)
            If pBegV < 0# Then pBegV = 0#
            If pPoV < 0# Then pPoV = 0#
            pAvail = pBegV + pPoV

            If pAvail <= 0# Then GoTo NextPartner

            ' partner has to keep enough to cover its OWN demand first (selfShip)
            Dim pSelfShip As Double
            pSelfShip = MapGetDbl(selfShipByCity(pj), skuKey, 0#)

            ' and canâ€™t donate the same stock twice
            Dim pAlreadyDonated As Double
            pAlreadyDonated = MapGetDbl(donatedByCity(pj), skuKey, 0#)

            Dim pRemaining As Double
            pRemaining = pAvail - pSelfShip - pAlreadyDonated
            If pRemaining <= 0# Then GoTo NextPartner

            Dim shipFromPartner As Double
            If need < pRemaining Then shipFromPartner = need Else shipFromPartner = pRemaining

            ' apply partner shipment
            shippedByDC(j) = shippedByDC(j) + shipFromPartner
            unfulByDC(j) = unfulByDC(j) - shipFromPartner
            need = need - shipFromPartner
            ' NEW: outbound from the partner city (pj) to fulfill other cities
            outOfCityByDC(pj) = outOfCityByDC(pj) + shipFromPartner


'==================== NEW: accumulate shipped-from-partner totals ====================
Dim partnerCity As String
partnerCity = CStr(dcNames(pj)) ' or use pSheet if you prefer sheet labels

MapAddDbl shippedFromPartnerByDemand(j), partnerCity, shipFromPartner
'====================================================================================


            ' track donation so we don't double-count partner inventory
            MapSet donatedByCity(pj), skuKey, pAlreadyDonated + shipFromPartner

            If need <= 0# Then Exit For

NextPartner:
        Next p

        ' update remaining demand map (optional, but keeps it consistent)
        If need > 0# Then
            MapSetRounded3 remDemandByCity(j), skuKey, need
        Else
            MapRemove remDemandByCity(j), skuKey
        End If

NextSkuPartner:
    Next sku

Next j

'==================== NEW: carry SKU backlog forward to next week ====================
For j = LBound(dcSheets) To UBound(dcSheets)
    Set backlogByCity(j) = New Collection
    Set backlogKeysByCity(j) = New Collection

    Dim bk As Variant
    For Each bk In remKeysByCity(j)
        skuKey = CStr(bk)
        MapSet backlogByCity(j), skuKey, MapGetDbl(remDemandByCity(j), skuKey, 0#)
        AddUniqueKey backlogKeysByCity(j), skuKey
    Next bk
Next j

'=====================================================================================



        ' Emit one row per city for this week
        For j = LBound(dcSheets) To UBound(dcSheets)
            outArr(outPtr, 1) = CStr(dcNames(j))
            outArr(outPtr, 2) = wkArr(w)
            outArr(outPtr, 3) = wkEnd
            outArr(outPtr, 4) = Round3(shippedByDC(j))
            outArr(outPtr, 5) = Round3(unfulByDC(j))


            dbgArr(outPtr, 1) = CStr(dcNames(j))
            dbgArr(outPtr, 2) = wkArr(w)
            dbgArr(outPtr, 3) = wkEnd

            dbgArr(outPtr, 4) = Round3(backlogTotalByDC(j))
            dbgArr(outPtr, 5) = Round3(salesByDC(j))
            dbgArr(outPtr, 6) = Round3(effectiveDemandByDC(j))
            dbgArr(outPtr, 7) = Round3(shippedLocalByDC(j))

'==================== NEW: write partner shipped breakdown ====================
Dim partnersEmit As Variant
partnersEmit = PartnersFor(CStr(dcSheets(j)))

Dim p1City As String, p2City As String
Dim p1Ship As Double, p2Ship As Double

p1City = "": p2City = ""
p1Ship = 0#: p2Ship = 0#

If Not IsEmpty(partnersEmit) Then
    If UBound(partnersEmit) >= 0 Then
        p1City = CStr(dcNames(FindDCIndexBySheetName(CStr(partnersEmit(0)))))
        p1Ship = MapGetDbl(shippedFromPartnerByDemand(j), p1City, 0#)
    End If
    If UBound(partnersEmit) >= 1 Then
        p2City = CStr(dcNames(FindDCIndexBySheetName(CStr(partnersEmit(1)))))
        p2Ship = MapGetDbl(shippedFromPartnerByDemand(j), p2City, 0#)
    End If
End If

dbgArr(outPtr, 8) = p1City
dbgArr(outPtr, 9) = Round3(p1Ship)
dbgArr(outPtr, 10) = p2City
dbgArr(outPtr, 11) = Round3(p2Ship)

Dim boxesShipped As Double
boxesShipped = shippedLocalByDC(j) + p1Ship + p2Ship

dbgArr(outPtr, 12) = Round3(boxesShipped)
dbgArr(outPtr, 13) = Round3(unfulByDC(j))
dbgArr(outPtr, 14) = Round3(shippedLocalByDC(j) + outOfCityByDC(j))

outPtr = outPtr + 1

        Next j
    Next w

    ' Write results
    If outRows > 0 Then
        wsOut.Range("A2").Resize(outRows, 5).Value = outArr
        wsDbg.Range("A2").Resize(outRows, 14).Value = dbgArr
    End If

    ' Format
    wsOut.Columns("A:E").AutoFit
    wsDbg.Columns("A:N").AutoFit

    wsOut.Range("B:C").NumberFormat = "yyyy-mm-dd"
    wsDbg.Range("B:C").NumberFormat = "yyyy-mm-dd"

    MsgBox "Done. Start week Dec 1t 2025. See '" & OUT_SHEET & "' and '" & DBG_SHEET & "'.", vbInformation

CleanDone:
    Application.ScreenUpdating = scrState
    Application.EnableEvents = evtState
    Application.Calculation = calcState
    Exit Sub

CleanFail:
    MsgBox "Error " & Err.Number & ": " & Err.Description, vbExclamation
    Resume CleanDone
End Sub

'============================= CONFIG =============================

Private Sub InitConfig()
    dcSheets = VBA.Array("RUGS-TOR", "RUGS-VAN", "RUGS-MTL", "RUGS-Moreno", "RUGS-Dayton")
    dcNames = VBA.Array("Toronto", "Vancouver", "Montreal", "Moreno", "Dayton")

    ' Per your note:
    ' TOR/VAN/MTL -> column B
    ' Moreno/Dayton -> column C
    skuColLetters = VBA.Array("B", "B", "B", "C", "C")
End Sub

'============================= SECTION RANGES (label-locked) =============================

Private Function GetSectionRange(ws As Worksheet, ByVal label As String, ByRef dataStartRow As Long, ByRef dataEndRow As Long) As Boolean
    Dim hdrCol As Long: hdrCol = ColLetterToNumber(HEADER_COL)
    Dim hdrRow As Long: hdrRow = FindLabelRow(ws, hdrCol, label)
    If hdrRow = 0 Then Exit Function

    dataStartRow = hdrRow + 1

    Dim nextHdr As Long: nextHdr = FindNextSectionHeaderRow(ws, hdrCol, dataStartRow)
    If nextHdr > 0 Then
        dataEndRow = nextHdr - 1
    Else
        dataEndRow = ws.UsedRange.Rows(ws.UsedRange.Rows.Count).Row
    End If

    If dataEndRow < dataStartRow Then dataEndRow = dataStartRow - 1
    GetSectionRange = True
End Function

Private Function FindLabelRow(ws As Worksheet, ByVal hdrCol As Long, ByVal label As String) As Long
    Dim want As String: want = NormalizeLabel(label)
    Dim lastRow As Long: lastRow = ws.UsedRange.Rows(ws.UsedRange.Rows.Count).Row
    If lastRow < 1 Then lastRow = 1

    Dim r As Long
    For r = 1 To WorksheetFunction.Min(lastRow, 10000)
        Dim got As String: got = NormalizeLabel(CStr(ws.Cells(r, hdrCol).Value))
        If got = want Then
            FindLabelRow = r
            Exit Function
        End If
    Next r
End Function

Private Function FindNextSectionHeaderRow(ws As Worksheet, ByVal hdrCol As Long, ByVal startRow As Long) As Long
    Dim lastRow As Long: lastRow = ws.UsedRange.Rows(ws.UsedRange.Rows.Count).Row
    If lastRow < 1 Then lastRow = 1

    Dim r As Long
    For r = startRow To WorksheetFunction.Min(lastRow, 10000)
        Dim got As String: got = NormalizeLabel(CStr(ws.Cells(r, hdrCol).Value))
        If IsKnownHeader(got) Then
            FindNextSectionHeaderRow = r
            Exit Function
        End If
    Next r
End Function

Private Function NormalizeLabel(ByVal s As String) As String
    Dim t As String
    t = UCase$(Trim$(CStr(s)))
    t = Replace$(t, Chr$(160), " ")
    NormalizeLabel = t
End Function

Private Function IsKnownHeader(ByVal norm As String) As Boolean
    IsKnownHeader = (norm = NormalizeLabel(LBL_BEGIN) Or _
                     norm = NormalizeLabel(LBL_END) Or _
                     norm = NormalizeLabel(LBL_SALES) Or _
                     norm = NormalizeLabel(LBL_PO))
End Function

'============================= WEEK HELPERS =============================

Private Function WeekStartAt(ws As Worksheet, ByVal colIdx As Long) As Date
    If IsDate(ws.Cells(2, colIdx).Value) Then
        WeekStartAt = CDate(ws.Cells(2, colIdx).Value)
    Else
        WeekStartAt = 0
    End If
End Function

Private Function WeekEndAt(ws As Worksheet, ByVal colIdx As Long) As Date
    If IsDate(ws.Cells(4, colIdx).Value) Then
        WeekEndAt = CDate(ws.Cells(4, colIdx).Value)
    Else
        WeekEndAt = 0
    End If
End Function

'============================= PARTNER RULES =============================

Private Function PartnersFor(ByVal demandSheetName As String) As Variant
    Select Case UCase$(demandSheetName)
        Case "RUGS-MTL":     PartnersFor = VBA.Array("RUGS-TOR", "RUGS-VAN")
        Case "RUGS-TOR":     PartnersFor = VBA.Array("RUGS-MTL", "RUGS-VAN")
        Case "RUGS-VAN":     PartnersFor = VBA.Array("RUGS-TOR", "RUGS-MTL")
        Case "RUGS-DAYTON":  PartnersFor = VBA.Array("RUGS-MORENO")
        Case "RUGS-MORENO":  PartnersFor = VBA.Array("RUGS-DAYTON")
        Case Else:           PartnersFor = VBA.Array()
    End Select
End Function

Private Function FindDCIndexBySheetName(ByVal sheetName As String) As Long
    Dim i As Long
    For i = LBound(dcSheets) To UBound(dcSheets)
        If UCase$(CStr(dcSheets(i))) = UCase$(sheetName) Then
            FindDCIndexBySheetName = i
            Exit Function
        End If
    Next i
    FindDCIndexBySheetName = -1
End Function

'============================= COLLECTION MAP UTILS =============================

Private Sub MapSet(ByRef m As Collection, ByVal key As String, ByVal val As Variant)
    If m Is Nothing Then Set m = New Collection
    On Error Resume Next
    m.Remove key
    On Error GoTo 0
    m.Add val, key
End Sub

Private Function MapExists(ByRef m As Collection, ByVal key As String) As Boolean
    On Error Resume Next
    Dim tmp As Variant: tmp = m.Item(key)
    MapExists = (Err.Number = 0)
    Err.Clear
    On Error GoTo 0
End Function

Private Function MapGetLong(ByRef m As Collection, ByVal key As String, ByVal def As Long) As Long
    On Error Resume Next
    MapGetLong = CLng(m.Item(key))
    If Err.Number <> 0 Then MapGetLong = def
    Err.Clear
    On Error GoTo 0
End Function

Private Function MapGetDate(ByRef m As Collection, ByVal key As String, ByVal def As Date) As Date
    On Error Resume Next
    MapGetDate = CDate(m.Item(key))
    If Err.Number <> 0 Then MapGetDate = def
    Err.Clear
    On Error GoTo 0
End Function

Private Sub AddUniqueKey(ByRef c As Collection, ByVal key As String)
    On Error Resume Next
    Dim tmp As Variant: tmp = c.Item(key)
    If Err.Number <> 0 Then
        Err.Clear
        c.Add key, key
    Else
        Err.Clear
    End If
End Sub

Private Sub AddUniqueDate(ByRef c As Collection, ByVal d As Date)
    Dim key As String: key = Format$(d, "yyyymmdd")
    On Error Resume Next
    Dim tmp As Variant: tmp = c.Item(key)
    If Err.Number <> 0 Then
        Err.Clear
        c.Add d, key
    Else
        Err.Clear
    End If
End Sub

Private Function CollDatesToArray(ByRef c As Collection) As Date()
    Dim arr() As Date
    Dim i As Long
    ReDim arr(0 To c.Count - 1)
    For i = 1 To c.Count
        arr(i - 1) = CDate(c.Item(i))
    Next i
    CollDatesToArray = arr
End Function

Private Sub SortDates(arr() As Date)
    Dim i As Long, j As Long
    Dim key As Date
    For i = LBound(arr) + 1 To UBound(arr)
        key = arr(i): j = i - 1
        Do While j >= LBound(arr) And arr(j) > key
            arr(j + 1) = arr(j)
            j = j - 1
        Loop
        arr(j + 1) = key
    Next i
End Sub

'============================= MISC =============================

Private Function ColLetterToNumber(ByVal colLetters As String) As Long
    Dim s As String: s = UCase$(Trim$(colLetters))
    Dim i As Long, n As Long
    For i = 1 To Len(s)
        If Mid$(s, i, 1) < "A" Or Mid$(s, i, 1) > "Z" Then Exit For
        n = n * 26 + (Asc(Mid$(s, i, 1)) - Asc("A") + 1)
    Next i
    ColLetterToNumber = n
End Function

Private Function WeekStartColBySheet(ByVal sheetName As String) As Long
    Select Case UCase$(sheetName)
        Case "RUGS-MTL":     WeekStartColBySheet = ColLetterToNumber(MTL_START_COL)
        Case "RUGS-TOR":     WeekStartColBySheet = ColLetterToNumber(TO_START_COL)
        Case "RUGS-VAN":     WeekStartColBySheet = ColLetterToNumber(VAN_START_COL)
        Case "RUGS-DAYTON":  WeekStartColBySheet = ColLetterToNumber(DAY_START_COL)
        Case "RUGS-MORENO":  WeekStartColBySheet = ColLetterToNumber(MOR_START_COL)
        Case Else:           WeekStartColBySheet = 1
    End Select
End Function

Private Function WeekEndColBySheet(ByVal sheetName As String, ByVal lastUsedCol As Long) As Long
    Select Case UCase$(sheetName)
        Case "RUGS-MTL":     WeekEndColBySheet = ColLetterToNumber(MTL_END_COL)
        Case "RUGS-TOR":     WeekEndColBySheet = ColLetterToNumber(TO_END_COL)
        Case "RUGS-VAN":     WeekEndColBySheet = ColLetterToNumber(VAN_END_COL)
        Case "RUGS-DAYTON":  WeekEndColBySheet = ColLetterToNumber(DAY_END_COL)
        Case "RUGS-MORENO":  WeekEndColBySheet = ColLetterToNumber(MOR_END_COL)
        Case Else:           WeekEndColBySheet = lastUsedCol
    End Select

    ' safety clamp so we don't loop past the sheet
    If WeekEndColBySheet > lastUsedCol Then WeekEndColBySheet = lastUsedCol
    If WeekEndColBySheet < 1 Then WeekEndColBySheet = 1
End Function

Private Function SheetExists(ByVal name As String) As Boolean
    On Error Resume Next
    SheetExists = Not ThisWorkbook.Worksheets(name) Is Nothing
    On Error GoTo 0
End Function

Private Function EnsureOutputSheet(wb As Workbook, ByVal name As String) As Worksheet
    If SheetExists(name) Then
        Set EnsureOutputSheet = wb.Worksheets(name)
    Else
        Set EnsureOutputSheet = wb.Worksheets.Add(After:=wb.Worksheets(wb.Worksheets.Count))
        EnsureOutputSheet.name = name
    End If
End Function

Private Function ValD(ByVal v As Variant) As Double
    If IsError(v) Or IsNull(v) Then ValD = 0#: Exit Function
    Dim s As String: s = CStr(v)
    s = Replace$(s, Chr$(160), " ")
    s = Replace$(s, ",", "")
    s = Trim$(s)
    If Len(s) = 0 Or Not IsNumeric(s) Then ValD = 0# Else ValD = CDbl(s)
End Function

'============================= FAST SECTION AGG (cross-platform) =============================

Private Function MapGetDbl(ByRef m As Collection, ByVal key As String, ByVal def As Double) As Double
    On Error Resume Next
    MapGetDbl = CDbl(m.Item(key))
    If Err.Number <> 0 Then MapGetDbl = def
    Err.Clear
    On Error GoTo 0
End Function

Private Sub MapAddDbl(ByRef m As Collection, ByVal key As String, ByVal addVal As Double)
    ' Adds addVal to existing value in Collection "map", or creates it.
    If m Is Nothing Then Set m = New Collection
    Dim cur As Double
    cur = MapGetDbl(m, key, 0#) + addVal
    MapSet m, key, cur
End Sub

Private Sub MapRemove(ByRef m As Collection, ByVal key As String)
    On Error Resume Next
    m.Remove key
    On Error GoTo 0
End Sub

Private Function Round3(ByVal x As Double) As Double
    ' Round to 3 decimals and snap tiny floating noise to 0
    Dim y As Double
    y = WorksheetFunction.Round(x, 3)
    If Abs(y) < 0.0005 Then y = 0#
    Round3 = y
End Function

Private Sub MapSetRounded3(ByRef m As Collection, ByVal key As String, ByVal val As Double)
    ' store a backlog value already rounded/cleaned
    MapSet m, key, Round3(val)
End Sub


Private Function ToDoubleFast(ByVal v As Variant) As Double
    ' Faster than ValD for typical numeric cells; falls back to lightweight string handling.
    If IsError(v) Or IsNull(v) Then Exit Function

    If IsNumeric(v) Then
        ToDoubleFast = CDbl(v)
        Exit Function
    End If

    Dim s As String
    s = Trim$(CStr(v))
    If Len(s) = 0 Then Exit Function
    s = Replace$(s, Chr$(160), " ")
    s = Replace$(s, ",", "")
    If IsNumeric(s) Then ToDoubleFast = CDbl(s)
End Function

Private Function SumSectionBySkuMap( _
    ws As Worksheet, _
    ByVal rStart As Long, ByVal rEnd As Long, _
    ByVal skuCol As Long, ByVal valCol As Long, _
    ByRef skuKeys As Collection _
) As Collection

    Dim m As Collection: Set m = New Collection

    If rStart < 1 Or rEnd < rStart Then
        Set SumSectionBySkuMap = m
        Exit Function
    End If


    ' Read SKU + values in bulk (fast)
    Dim skuArr As Variant, valArr As Variant
    skuArr = ws.Range(ws.Cells(rStart, skuCol), ws.Cells(rEnd, skuCol)).Value2
    valArr = ws.Range(ws.Cells(rStart, valCol), ws.Cells(rEnd, valCol)).Value2

    Dim i As Long, sku As String, v As Double
    For i = 1 To UBound(skuArr, 1)
        sku = Trim$(CStr(skuArr(i, 1)))
        If Len(sku) > 0 Then
            v = ToDoubleFast(valArr(i, 1))
            If v <> 0# Then
                MapAddDbl m, sku, v
                If Not skuKeys Is Nothing Then AddUniqueKey skuKeys, sku
            End If
        End If
    Next i

    Set SumSectionBySkuMap = m
End Function




